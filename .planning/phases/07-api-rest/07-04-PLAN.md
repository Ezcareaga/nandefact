---
phase: 07-api-rest
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - src/interfaces/http/schemas/facturaSchemas.ts
  - src/interfaces/http/schemas/syncSchemas.ts
  - src/interfaces/http/routes/facturaRoutes.ts
  - src/interfaces/http/routes/syncRoutes.ts
  - src/interfaces/http/server.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/facturas creates a factura with validated items and returns CDC"
    - "GET /api/v1/facturas returns paginated factura list with filters"
    - "GET /api/v1/facturas/:id returns factura detail"
    - "POST /api/v1/facturas/:id/anular sends cancelation event to SIFEN"
    - "POST /api/v1/sync/push enqueues a factura for SIFEN processing"
    - "Server starts and listens on configured port"
    - "All routes are mounted on the Express app under /api/v1"
  artifacts:
    - path: "src/interfaces/http/schemas/facturaSchemas.ts"
      provides: "Zod schemas for factura endpoints"
      exports: ["crearFacturaSchema", "listarFacturasQuerySchema", "anularFacturaSchema"]
    - path: "src/interfaces/http/schemas/syncSchemas.ts"
      provides: "Zod schemas for sync endpoints"
      exports: ["syncPushSchema", "syncPullQuerySchema"]
    - path: "src/interfaces/http/routes/facturaRoutes.ts"
      provides: "Express router for /api/v1/facturas/*"
      exports: ["createFacturaRouter"]
    - path: "src/interfaces/http/routes/syncRoutes.ts"
      provides: "Express router for /api/v1/sync/*"
      exports: ["createSyncRouter"]
    - path: "src/interfaces/http/server.ts"
      provides: "Server startup with route mounting"
      exports: ["startServer"]
    - path: "src/index.ts"
      provides: "Application entry point"
  key_links:
    - from: "src/interfaces/http/routes/facturaRoutes.ts"
      to: "src/application/facturacion/CrearFactura.ts"
      via: "use case execute"
      pattern: "crearFactura\\.execute"
    - from: "src/interfaces/http/routes/facturaRoutes.ts"
      to: "src/application/facturacion/AnularFactura.ts"
      via: "use case execute"
      pattern: "anularFactura\\.execute"
    - from: "src/interfaces/http/routes/syncRoutes.ts"
      to: "src/application/sync/EncolarFactura.ts"
      via: "use case execute"
      pattern: "encolarFactura\\.execute"
    - from: "src/interfaces/http/server.ts"
      to: "src/interfaces/http/app.ts"
      via: "createApp call"
      pattern: "createApp"
    - from: "src/index.ts"
      to: "src/interfaces/http/server.ts"
      via: "startServer call"
      pattern: "startServer"
---

<objective>
Create Zod schemas and route handlers for Facturas (create, list, detail, KuDE download, resend, cancel, inutilize) and Sync (push, pull, status) endpoints. Wire ALL routes into the Express app via server.ts. Update index.ts to start the server. This plan completes the entire API REST layer.

Purpose: Factura routes are the core business value (creating and managing invoices). Sync routes enable offline-first functionality. Server wiring makes everything accessible.
Output: 6 files - schemas, routes, server.ts, updated index.ts. Complete working API.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/ez/projects/nandefact/CLAUDE.md
@/home/ez/projects/nandefact/.planning/ROADMAP.md
@/home/ez/projects/nandefact/.planning/phases/07-api-rest/07-01-SUMMARY.md
@/home/ez/projects/nandefact/.planning/phases/07-api-rest/07-02-SUMMARY.md
@/home/ez/projects/nandefact/.planning/phases/07-api-rest/07-03-SUMMARY.md
@/home/ez/projects/nandefact/nandefact-api/src/application/facturacion/CrearFactura.ts
@/home/ez/projects/nandefact/nandefact-api/src/application/facturacion/EnviarDE.ts
@/home/ez/projects/nandefact/nandefact-api/src/application/facturacion/AnularFactura.ts
@/home/ez/projects/nandefact/nandefact-api/src/application/facturacion/EnviarKuDE.ts
@/home/ez/projects/nandefact/nandefact-api/src/application/facturacion/InutilizarNumeracion.ts
@/home/ez/projects/nandefact/nandefact-api/src/application/sync/EncolarFactura.ts
@/home/ez/projects/nandefact/nandefact-api/src/application/sync/SincronizarPendientes.ts
@/home/ez/projects/nandefact/nandefact-api/src/domain/factura/IFacturaRepository.ts
@/home/ez/projects/nandefact/nandefact-api/src/domain/shared/types.ts
@/home/ez/projects/nandefact/nandefact-api/src/interfaces/http/app.ts
@/home/ez/projects/nandefact/nandefact-api/src/interfaces/http/middleware/errorHandler.ts
@/home/ez/projects/nandefact/nandefact-api/src/interfaces/http/routes/authRoutes.ts
@/home/ez/projects/nandefact/nandefact-api/src/interfaces/http/routes/comercioRoutes.ts
@/home/ez/projects/nandefact/nandefact-api/src/interfaces/http/routes/productoRoutes.ts
@/home/ez/projects/nandefact/nandefact-api/src/interfaces/http/routes/clienteRoutes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas and routes for facturas and sync</name>
  <files>
    src/interfaces/http/schemas/facturaSchemas.ts
    src/interfaces/http/schemas/syncSchemas.ts
    src/interfaces/http/routes/facturaRoutes.ts
    src/interfaces/http/routes/syncRoutes.ts
  </files>
  <action>
    1. Create `src/interfaces/http/schemas/facturaSchemas.ts`:
       - `crearFacturaSchema`: body with:
         - clienteId: z.string().uuid()
         - tipoDocumento: z.union([z.literal(1), z.literal(5), z.literal(6), z.literal(7)]) (TipoDocumento type)
         - condicionPago: z.enum(['contado', 'credito'])
         - fechaEmision: z.coerce.date()
         - numero: z.string().regex(/^\d{7}$/, 'Numero debe ser 7 digitos')
         - items: z.array(z.object({
             productoId: z.string().uuid(),
             descripcion: z.string().trim().min(1).max(200),
             cantidad: z.number().int().positive(),
             precioUnitario: z.number().int().positive(),
             tasaIVA: z.union([z.literal(10), z.literal(5), z.literal(0)])
           })).min(1, 'La factura debe tener al menos un item')
         - facturaReferenciaId: z.string().uuid().optional() (for notas de credito)
       - `listarFacturasQuerySchema`: query with:
         - page: z.coerce.number().int().positive().optional().default(1)
         - pageSize: z.coerce.number().int().positive().max(100).optional().default(20)
         - estado: z.enum(['pendiente', 'enviado', 'aprobado', 'rechazado', 'contingencia', 'cancelado']).optional()
         - fechaDesde: z.coerce.date().optional()
         - fechaHasta: z.coerce.date().optional()
       - `anularFacturaSchema`: body with:
         - motivo: z.string().trim().min(1).max(500)
       - `inutilizarNumeracionSchema`: body with:
         - establecimiento: z.string().regex(/^\d{3}$/)
         - punto: z.string().regex(/^\d{3}$/)
         - desde: z.number().int().positive()
         - hasta: z.number().int().positive()
         - motivo: z.string().trim().min(1).max(500)
       - `facturaIdParamSchema`: params with id: z.string().uuid()

    2. Create `src/interfaces/http/schemas/syncSchemas.ts`:
       - `syncPushSchema`: body with:
         - facturaId: z.string().uuid()
       - `syncPullQuerySchema`: query with:
         - since: z.coerce.date() (ISO timestamp)
       - No schema needed for GET /status (just uses req.user.comercioId)

    3. Create `src/interfaces/http/routes/facturaRoutes.ts`:
       - Export `createFacturaRouter(deps: AppDependencies): Router`
       - Apply authMiddleware to ALL routes.
       - Routes:
         - `POST /`: validateRequest({ body: crearFacturaSchema }) -> deps.crearFactura.execute({ comercioId: req.user!.comercioId, ...body }) -> 201 with { success: true, data: { facturaId, cdc, estado, totalBruto, totalIVA10, totalIVA5, totalExenta, totalIVA } }
         - `GET /`: validateRequest({ query: listarFacturasQuerySchema }) -> load facturas from deps.facturaRepository.findByComercio(req.user!.comercioId). Apply filters in-memory for now (estado, fecha range). Apply pagination in-memory. Return 200 with { success: true, data: { facturas: [...mapped], total, page, pageSize } }. Map each factura to: { id, cdc (string or null), numero (formatted), tipoDocumento, estado, totalBruto, totalIVA, condicionPago, fechaEmision, clienteId }.
         - `GET /:id`: validateRequest({ params: facturaIdParamSchema }) -> deps.facturaRepository.findById(id). If factura exists and factura.comercioId === req.user!.comercioId -> return full detail. If not found or wrong comercio -> 404. Return 200 with { success: true, data: { full factura properties } }.
         - `GET /:id/kude`: validateRequest({ params: facturaIdParamSchema }) -> deps.enviarKuDE.execute({ facturaId: id }). The use case generates PDF and optionally sends WhatsApp. Return 200 with { success: true, data: { pdfGenerado, notificacionEnviada, telefono } }. NOTE: Actual PDF download (streaming the file) deferred to Phase 8 when KuDE storage is wired. For now, trigger generation and return status.
         - `POST /:id/reenviar`: validateRequest({ params: facturaIdParamSchema }) -> deps.enviarKuDE.execute({ facturaId: id }) -> 200 with { success: true, data: { notificacionEnviada, telefono } }
         - `POST /:id/anular`: validateRequest({ params: facturaIdParamSchema, body: anularFacturaSchema }) -> deps.anularFactura.execute({ facturaId: id, motivo: body.motivo }) -> 200 with { success: true, data: { cdc, codigoRespuesta, mensajeRespuesta, anulada } }
         - `POST /inutilizar-numeracion`: validateRequest({ body: inutilizarNumeracionSchema }) -> deps.inutilizarNumeracion.execute({ comercioId: req.user!.comercioId, ...body }) -> 200 with { success: true, data: { codigoRespuesta, mensajeRespuesta, inutilizado } }

       IMPORTANT: For GET /:id, verify factura.comercioId matches req.user!.comercioId to prevent cross-comercio access.

    4. Create `src/interfaces/http/routes/syncRoutes.ts`:
       - Export `createSyncRouter(deps: AppDependencies): Router`
       - Apply authMiddleware to ALL routes.
       - Routes:
         - `POST /push`: validateRequest({ body: syncPushSchema }) -> deps.encolarFactura.execute({ facturaId: body.facturaId }) -> 200 with { success: true, data: { jobId, cdc } }
         - `GET /pull`: validateRequest({ query: syncPullQuerySchema }) -> Load facturas from deps.facturaRepository.findByComercio(req.user!.comercioId). Filter by updated_at > since (if available on entity, else return all). Return 200 with { success: true, data: { facturas: [...], syncTimestamp: new Date().toISOString() } }. NOTE: Full delta sync requires updatedAt tracking in Factura entity which may not exist yet; for now return all facturas and let client filter. Document this limitation.
         - `GET /status`: Load pending facturas count from deps.facturaRepository.findPendientes(req.user!.comercioId) -> 200 with { success: true, data: { pendientes: count, ultimaSync: null } }. NOTE: ultimaSync tracking deferred to infrastructure.

    Use asyncHandler pattern for all async route handlers (same as Plans 02/03).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx eslint src/interfaces/` passes
    - facturaRoutes has 7 endpoints (POST, GET, GET/:id, GET/:id/kude, POST/:id/reenviar, POST/:id/anular, POST/inutilizar-numeracion)
    - syncRoutes has 3 endpoints (POST/push, GET/pull, GET/status)
    - All routes use authMiddleware and Zod validation
  </verify>
  <done>Factura router: 7 endpoints for full facturacion lifecycle. Sync router: 3 endpoints for offline sync. All protected, validated, wired to use cases.</done>
</task>

<task type="auto">
  <name>Task 2: Create server.ts and wire all routes in index.ts</name>
  <files>
    src/interfaces/http/server.ts
    src/index.ts
  </files>
  <action>
    1. Create `src/interfaces/http/server.ts`:
       - Export `startServer(deps: AppDependencies, port?: number): void`
       - Inside:
         a. Call createApp(deps) to get the Express app.
         b. Create auth middleware instance: createAuthMiddleware(deps.authService)
         c. Mount ALL route groups on the app:
            - app.use('/api/v1/auth', createAuthRouter(deps))
            - app.use('/api/v1/comercio', createComercioRouter(deps))
            - app.use('/api/v1/productos', createProductoRouter(deps))
            - app.use('/api/v1/clientes', createClienteRouter(deps))
            - app.use('/api/v1/facturas', createFacturaRouter(deps))
            - app.use('/api/v1/sync', createSyncRouter(deps))
         d. Mount the error handler as LAST middleware: app.use(errorHandler)
         e. Add a health check route: GET /health -> 200 { status: 'ok', timestamp: new Date().toISOString() }
         f. Start listening: app.listen(port || 3000, () => console.log(`nandefact-api listening on port ${port || 3000}`))
         g. Return the HTTP server for testing purposes.

    2. Update `src/index.ts`:
       - Import startServer and AppDependencies.
       - Create a bootstrapDeps() function that constructs stub/placeholder dependencies for now. Since we don't have real infrastructure adapters for repositories yet (PostgreSQL, Phase 8), create minimal inline stubs that throw "Not implemented" errors. This lets the server START and routes be exercised.
       - Specifically, create stubs for: IAuthService, IHashService, all repositories (IFacturaRepository, IComercioRepository, IProductoRepository, IClienteRepository, IUsuarioRepository), ISifenGateway, IXmlGenerator, IFirmaDigital, ISyncQueue, IKudeGenerator, INotificador, ICertificadoStore, ILogger.
       - Instantiate all 16 use cases with the stub dependencies.
       - Call startServer(deps, parseInt(process.env.PORT || '3000')).
       - Read port from process.env.PORT (default 3000).

    NOTE: The stubs are temporary. Phase 8 will provide real PostgreSQL repositories and full Docker Compose integration. The stubs allow:
    - `npm run dev` starts the server
    - Routes respond to requests (with "Not implemented" errors from stubs)
    - TypeScript compilation validates all wiring is correct
    - Server startup is verified

    The index.ts should be clean and not overly long. Group the stub creation logically. Mark each stub with a TODO comment referencing Phase 8.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx eslint src/` passes
    - `npm run build` succeeds (tsc compiles to dist/)
    - `PORT=3001 timeout 5 npx tsx src/index.ts &` starts server, then `curl http://localhost:3001/health` returns { status: 'ok' }. Kill the background process.
    - `curl http://localhost:3001/api/v1/auth/login -X POST -H 'Content-Type: application/json' -d '{}'` returns 400 with Zod validation error (proves middleware works)
  </verify>
  <done>Server starts on configured port. All 6 route groups mounted under /api/v1/*. Health check responds. Error handler catches all errors. Zod validation rejects invalid input. Auth middleware blocks unauthenticated access to protected routes. index.ts bootstraps with stub dependencies (replaced by real infra in Phase 8). `npm run dev` works end-to-end.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx eslint src/` passes
- `npm run build` produces dist/ with compiled JS
- Server starts with `npm run dev` and responds to /health
- POST /api/v1/auth/login with empty body returns 400 (Zod error)
- POST /api/v1/auth/login with valid body returns 401/500 (stub throws, mapped by error handler)
- GET /api/v1/productos without Authorization header returns 401
- All 25+ endpoints exist and route correctly
- Consistent response format throughout: { success: boolean, data?: T, error?: { code, message } }
</verification>

<success_criteria>
Complete API REST layer with 25+ endpoints across 6 route groups. Factura routes handle full lifecycle (create, list, detail, KuDE, resend, cancel, inutilize). Sync routes handle push, pull, status. Server.ts mounts all routes and starts Express. Index.ts bootstraps with stub dependencies. `npm run dev` starts working server. Zod validates all inputs. Error handler maps all domain/application errors. Auth middleware protects all non-public routes. TypeScript compiles, ESLint passes, build succeeds.
</success_criteria>

<output>
After completion, create `.planning/phases/07-api-rest/07-04-SUMMARY.md`
</output>
