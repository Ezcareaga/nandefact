---
phase: 03-sync-queue
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - nandefact-api/src/infrastructure/queue/SyncQueueBullMQ.ts
  - nandefact-api/src/infrastructure/queue/SyncWorker.ts
  - nandefact-api/src/infrastructure/logging/ConsoleLogger.ts
  - nandefact-api/tests/unit/infrastructure/queue/SyncQueueBullMQ.test.ts
  - nandefact-api/tests/unit/infrastructure/queue/SyncWorker.test.ts
  - nandefact-api/package.json
autonomous: true

must_haves:
  truths:
    - "BullMQ queue adapter implements ISyncQueue port and enqueues/dequeues jobs in FIFO order"
    - "Failed jobs retry with exponential backoff delays: 1s, 2s, 4s, 8s, 16s"
    - "SyncWorker dequeues jobs and invokes ProcesarColaSifen for each one"
    - "ConsoleLogger outputs structured JSON logs with comercioId and CDC context"
    - "Queue continues processing remaining jobs when one job fails"
  artifacts:
    - path: "nandefact-api/src/infrastructure/queue/SyncQueueBullMQ.ts"
      provides: "BullMQ adapter implementing ISyncQueue port"
      contains: "SyncQueueBullMQ"
    - path: "nandefact-api/src/infrastructure/queue/SyncWorker.ts"
      provides: "BullMQ worker that processes sync jobs"
      contains: "SyncWorker"
    - path: "nandefact-api/src/infrastructure/logging/ConsoleLogger.ts"
      provides: "Structured JSON logger implementing ILogger"
      contains: "ConsoleLogger"
    - path: "nandefact-api/tests/unit/infrastructure/queue/SyncQueueBullMQ.test.ts"
      provides: "Tests for BullMQ adapter"
    - path: "nandefact-api/tests/unit/infrastructure/queue/SyncWorker.test.ts"
      provides: "Tests for worker job processing"
  key_links:
    - from: "nandefact-api/src/infrastructure/queue/SyncQueueBullMQ.ts"
      to: "nandefact-api/src/domain/sync/ISyncQueue.ts"
      via: "implements"
      pattern: "implements ISyncQueue"
    - from: "nandefact-api/src/infrastructure/queue/SyncWorker.ts"
      to: "nandefact-api/src/application/sync/ProcesarColaSifen.ts"
      via: "dependency injection"
      pattern: "procesarColaSifen.*ProcesarColaSifen"
    - from: "nandefact-api/src/infrastructure/logging/ConsoleLogger.ts"
      to: "nandefact-api/src/domain/shared/ILogger.ts"
      via: "implements"
      pattern: "implements ILogger"
---

<objective>
Implement BullMQ infrastructure adapter for the ISyncQueue port, exponential backoff retry strategy, structured logging, and the worker that ties everything together.

Purpose: Complete the sync & queue system by providing the concrete BullMQ implementation. This connects the domain/application layer (from plan 03-01) to real Redis-backed queue processing with exponential backoff retries.

Output: BullMQ adapter, sync worker, console logger, npm dependencies (bullmq, ioredis), and tests.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sync-queue/03-01-SUMMARY.md
@nandefact-api/src/domain/sync/ISyncQueue.ts
@nandefact-api/src/domain/sync/SyncJob.ts
@nandefact-api/src/domain/shared/ILogger.ts
@nandefact-api/src/application/sync/ProcesarColaSifen.ts
@nandefact-api/src/application/sync/EncolarFactura.ts
@nandefact-api/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install BullMQ + ioredis, implement SyncQueueBullMQ adapter and ConsoleLogger</name>
  <files>
    nandefact-api/package.json,
    nandefact-api/src/infrastructure/queue/SyncQueueBullMQ.ts,
    nandefact-api/src/infrastructure/logging/ConsoleLogger.ts,
    nandefact-api/tests/unit/infrastructure/queue/SyncQueueBullMQ.test.ts,
    nandefact-api/tests/unit/infrastructure/logging/ConsoleLogger.test.ts
  </files>
  <action>
**Step 1: Install dependencies**
```bash
cd nandefact-api && npm install bullmq ioredis
```

**Step 2: ConsoleLogger** (`src/infrastructure/logging/ConsoleLogger.ts`)

Implements ILogger from domain/shared/ILogger.ts. Output structured JSON to stdout:
```typescript
export class ConsoleLogger implements ILogger {
  constructor(private readonly serviceName: string = 'nandefact-api') {}

  info(message: string, context?: Record<string, unknown>): void {
    console.log(JSON.stringify({
      level: 'info',
      service: this.serviceName,
      message,
      timestamp: new Date().toISOString(),
      ...context,
    }));
  }
  // warn and error follow same pattern, using console.warn and console.error
}
```

Simple test: verify JSON output format, verify context is included.

**Step 3: SyncQueueBullMQ adapter** (`src/infrastructure/queue/SyncQueueBullMQ.ts`)

Implements ISyncQueue using BullMQ Queue class.

```typescript
import { Queue, type JobsOptions } from 'bullmq';
import type { ISyncQueue } from '../../domain/sync/ISyncQueue.js';
import { SyncJob } from '../../domain/sync/SyncJob.js';

export class SyncQueueBullMQ implements ISyncQueue {
  private readonly queue: Queue;
  static readonly QUEUE_NAME = 'sifen-sync';

  constructor(redisConnection: { host: string; port: number }) {
    this.queue = new Queue(SyncQueueBullMQ.QUEUE_NAME, {
      connection: redisConnection,
      defaultJobOptions: {
        removeOnComplete: true,
        removeOnFail: false,  // Keep failed jobs for inspection
      },
    });
  }

  async encolar(job: SyncJob): Promise<void> {
    // Enqueue with FIFO ordering (default BullMQ behavior)
    await this.queue.add('procesar-factura', {
      id: job.id,
      comercioId: job.comercioId,
      facturaId: job.facturaId,
      cdc: job.cdc,
      fechaEmision: job.fechaEmision.toISOString(),
      intentos: job.intentos,
      maxIntentos: job.maxIntentos,
      ultimoError: job.ultimoError,
      creadoEn: job.creadoEn.toISOString(),
    });
  }

  async desencolar(): Promise<SyncJob | null> {
    // Note: In BullMQ, workers handle dequeuing automatically
    // This method is for direct queue inspection (used in testing/monitoring)
    const jobs = await this.queue.getJobs(['waiting'], 0, 0);
    if (jobs.length === 0) return null;
    const jobData = jobs[0].data;
    return new SyncJob({
      ...jobData,
      fechaEmision: new Date(jobData.fechaEmision),
      creadoEn: new Date(jobData.creadoEn),
    });
  }

  async completar(jobId: string): Promise<void> {
    // In worker context, BullMQ handles completion automatically
    // This is a no-op in BullMQ adapter (job removed by worker return)
    // Kept for port contract compliance
  }

  async fallar(job: SyncJob, error: string): Promise<void> {
    // Re-enqueue with incremented intentos and exponential backoff delay
    const updatedJob = job.conError(error);
    const delay = this.calcularBackoff(updatedJob.intentos);

    await this.queue.add('procesar-factura', {
      id: updatedJob.id,
      comercioId: updatedJob.comercioId,
      facturaId: updatedJob.facturaId,
      cdc: updatedJob.cdc,
      fechaEmision: updatedJob.fechaEmision.toISOString(),
      intentos: updatedJob.intentos,
      maxIntentos: updatedJob.maxIntentos,
      ultimoError: updatedJob.ultimoError,
      creadoEn: updatedJob.creadoEn.toISOString(),
    }, {
      delay,
      jobId: `${updatedJob.id}-retry-${updatedJob.intentos}`,
    });
  }

  async obtenerPendientes(comercioId: string): Promise<SyncJob[]> {
    const jobs = await this.queue.getJobs(['waiting', 'delayed'], 0, 100);
    return jobs
      .filter(j => j.data.comercioId === comercioId)
      .map(j => new SyncJob({
        ...j.data,
        fechaEmision: new Date(j.data.fechaEmision),
        creadoEn: new Date(j.data.creadoEn),
      }));
  }

  async contarPendientes(comercioId: string): Promise<number> {
    const pendientes = await this.obtenerPendientes(comercioId);
    return pendientes.length;
  }

  /**
   * Calcula delay de backoff exponencial: 1s, 2s, 4s, 8s, 16s
   * Formula: 2^(intento-1) * 1000 ms
   */
  calcularBackoff(intento: number): number {
    return Math.pow(2, intento - 1) * 1000;
  }

  /** Cierra la conexión al terminar */
  async close(): Promise<void> {
    await this.queue.close();
  }
}
```

**Tests for SyncQueueBullMQ:**
Mock the BullMQ Queue class entirely (no Redis needed for unit tests):
- Should add job to queue when encolar is called
- Should calculate correct backoff delays: intento 1 = 1000ms, 2 = 2000ms, 3 = 4000ms, 4 = 8000ms, 5 = 16000ms
- Should re-enqueue with delay when fallar is called
- Should serialize/deserialize SyncJob dates correctly
- calcularBackoff is a pure function, test it directly with multiple inputs

Mock approach: vi.mock('bullmq') to mock the Queue constructor and its methods (add, getJobs, close). Do NOT require a running Redis for unit tests.
  </action>
  <verify>
```bash
cd nandefact-api && npx tsc --noEmit
cd nandefact-api && npx vitest run tests/unit/infrastructure/queue/
cd nandefact-api && npx vitest run tests/unit/infrastructure/logging/
```
  </verify>
  <done>BullMQ and ioredis installed. SyncQueueBullMQ implements ISyncQueue with FIFO enqueue, exponential backoff (1s->2s->4s->8s->16s), and date serialization. ConsoleLogger outputs structured JSON. All unit tests pass with mocked BullMQ (no Redis required).</done>
</task>

<task type="auto">
  <name>Task 2: Implement SyncWorker that connects BullMQ worker to ProcesarColaSifen</name>
  <files>
    nandefact-api/src/infrastructure/queue/SyncWorker.ts,
    nandefact-api/tests/unit/infrastructure/queue/SyncWorker.test.ts
  </files>
  <action>
**SyncWorker** (`src/infrastructure/queue/SyncWorker.ts`)

This class creates a BullMQ Worker that listens on the sifen-sync queue and invokes ProcesarColaSifen for each job.

```typescript
import { Worker, type Job } from 'bullmq';
import { SyncJob } from '../../domain/sync/SyncJob.js';
import type { ProcesarColaSifen } from '../../application/sync/ProcesarColaSifen.js';
import type { ILogger } from '../../domain/shared/ILogger.js';
import { SyncQueueBullMQ } from './SyncQueueBullMQ.js';

export interface SyncWorkerDeps {
  procesarColaSifen: ProcesarColaSifen;
  logger: ILogger;
  redisConnection: { host: string; port: number };
}

export class SyncWorker {
  private worker: Worker | null = null;
  private readonly deps: SyncWorkerDeps;

  constructor(deps: SyncWorkerDeps) {
    this.deps = deps;
  }

  /**
   * Inicia el worker que escucha la cola sifen-sync.
   * Cada job es procesado por ProcesarColaSifen.
   */
  start(): void {
    this.worker = new Worker(
      SyncQueueBullMQ.QUEUE_NAME,
      async (job: Job) => {
        const syncJob = this.deserializeJob(job.data);

        this.deps.logger.info('Worker recibió job', {
          jobId: syncJob.id,
          comercioId: syncJob.comercioId,
          facturaId: syncJob.facturaId,
          cdc: syncJob.cdc,
          intento: syncJob.intentos + 1,
        });

        const resultado = await this.deps.procesarColaSifen.execute({ job: syncJob });

        this.deps.logger.info('Worker completó job', {
          jobId: syncJob.id,
          comercioId: syncJob.comercioId,
          cdc: syncJob.cdc,
          exito: resultado.exito,
          error: resultado.error,
        });

        return resultado;
      },
      {
        connection: this.deps.redisConnection,
        concurrency: 1,  // Procesar uno a la vez (FIFO estricto)
        limiter: {
          max: 10,        // Máximo 10 jobs por intervalo
          duration: 60000, // Por minuto (evitar saturar SIFEN)
        },
      },
    );

    // Manejar eventos del worker
    this.worker.on('completed', (job) => {
      this.deps.logger.info('Job completado en queue', {
        jobId: job?.id,
        bullmqJobId: job?.id,
      });
    });

    this.worker.on('failed', (job, err) => {
      this.deps.logger.error('Job falló en queue', {
        jobId: job?.id,
        bullmqJobId: job?.id,
        error: err.message,
      });
    });

    this.deps.logger.info('SyncWorker iniciado', {
      queue: SyncQueueBullMQ.QUEUE_NAME,
      concurrency: 1,
    });
  }

  /**
   * Deserializa datos del job BullMQ a SyncJob domain object.
   */
  private deserializeJob(data: Record<string, unknown>): SyncJob {
    return new SyncJob({
      id: data.id as string,
      comercioId: data.comercioId as string,
      facturaId: data.facturaId as string,
      cdc: data.cdc as string,
      fechaEmision: new Date(data.fechaEmision as string),
      intentos: data.intentos as number,
      maxIntentos: data.maxIntentos as number,
      ultimoError: data.ultimoError as string | undefined,
      creadoEn: new Date(data.creadoEn as string),
    });
  }

  /** Detiene el worker */
  async stop(): Promise<void> {
    if (this.worker) {
      await this.worker.close();
      this.worker = null;
      this.deps.logger.info('SyncWorker detenido');
    }
  }

  /** Devuelve si el worker está activo */
  isRunning(): boolean {
    return this.worker !== null;
  }
}
```

Key design decisions:
- `concurrency: 1` ensures strict FIFO order (one job at a time)
- Rate limiter: max 10 jobs per minute to avoid overwhelming SIFEN
- Worker logs every job start and completion with comercioId and CDC
- ProcesarColaSifen handles all business logic (72h check, retry logic)
- Worker is a thin adapter that deserializes BullMQ job data into domain SyncJob

**Tests for SyncWorker:**
Mock BullMQ Worker class:
- Should create worker with correct queue name and concurrency=1
- Should deserialize job data into SyncJob correctly (dates, intentos)
- Should call ProcesarColaSifen.execute with deserialized SyncJob
- Should log job start and completion with comercioId and CDC
- Should close worker on stop()
- Should report isRunning() correctly

Mock approach: vi.mock('bullmq') to capture the processor function passed to Worker constructor, then invoke it with mock job data to verify ProcesarColaSifen is called correctly.

Run ALL tests at the end to verify zero regressions:
```bash
cd nandefact-api && npx vitest run
```
  </action>
  <verify>
```bash
cd nandefact-api && npx tsc --noEmit
cd nandefact-api && npx vitest run tests/unit/infrastructure/queue/SyncWorker.test.ts
cd nandefact-api && npx vitest run  # All tests pass, zero regressions
```
  </verify>
  <done>SyncWorker connects BullMQ Worker to ProcesarColaSifen with concurrency=1 (FIFO), rate limiting (10/min), structured logging for every job. Worker deserializes BullMQ job data to domain SyncJob objects. All tests pass including 140+ existing tests.</done>
</task>

</tasks>

<verification>
```bash
cd nandefact-api
npx tsc --noEmit                                    # TypeScript compiles
npx vitest run tests/unit/infrastructure/queue/      # Queue tests pass
npx vitest run tests/unit/infrastructure/logging/    # Logger tests pass
npx vitest run                                       # ALL tests pass (140+ existing + new)
```
</verification>

<success_criteria>
1. BullMQ and ioredis are installed as dependencies in package.json
2. SyncQueueBullMQ implements ISyncQueue port with encolar/fallar/completar methods
3. Exponential backoff calculates correct delays: 1s, 2s, 4s, 8s, 16s
4. SyncWorker uses concurrency=1 for strict FIFO processing
5. SyncWorker logs every job with comercioId and CDC context
6. ConsoleLogger outputs structured JSON
7. All existing 140+ tests still pass (zero regressions)
8. New tests cover queue adapter, worker, and logger
</success_criteria>

<output>
After completion, create `.planning/phases/03-sync-queue/03-02-SUMMARY.md`
</output>
