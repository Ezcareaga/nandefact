---
phase: 08-infrastructure-testing
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/UsuarioRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/ProductoRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/ClienteRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts
  - nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts
  - nandefact-api/src/infrastructure/auth/HashServiceBcrypt.ts
  - nandefact-api/src/infrastructure/persistence/CertificadoStorePg.ts
  - nandefact-api/src/index.ts
autonomous: true

must_haves:
  truths:
    - "All 5 repository adapters implement their domain port interfaces with real Prisma queries"
    - "AuthServiceJWT generates and verifies JWT tokens with 15min access / 7day refresh"
    - "HashServiceBcrypt hashes and verifies PINs using bcrypt"
    - "index.ts uses real implementations instead of stubs when DATABASE_URL is set"
    - "Domain entity <-> Prisma model mapping is correct for all entities including value objects (RUC, Timbrado, CDC, NumeroFactura, MontoIVA)"
  artifacts:
    - path: "nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts"
      provides: "PostgreSQL adapter for IComercioRepository"
      exports: ["ComercioRepositoryPg"]
    - path: "nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts"
      provides: "PostgreSQL adapter for IFacturaRepository with items mapping"
      exports: ["FacturaRepositoryPg"]
    - path: "nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts"
      provides: "JWT token generation and verification"
      exports: ["AuthServiceJWT"]
    - path: "nandefact-api/src/infrastructure/auth/HashServiceBcrypt.ts"
      provides: "Bcrypt PIN hashing"
      exports: ["HashServiceBcrypt"]
    - path: "nandefact-api/src/index.ts"
      provides: "Wired application with real adapters"
      contains: "RepositoryPg"
  key_links:
    - from: "nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts"
      to: "nandefact-api/src/domain/factura/IFacturaRepository.ts"
      via: "implements IFacturaRepository"
      pattern: "implements IFacturaRepository"
    - from: "nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts"
      to: "nandefact-api/src/domain/auth/IAuthService.ts"
      via: "implements IAuthService"
      pattern: "implements IAuthService"
    - from: "nandefact-api/src/index.ts"
      to: "nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts"
      via: "import and instantiation"
      pattern: "ComercioRepositoryPg"
    - from: "nandefact-api/src/index.ts"
      to: "nandefact-api/src/infrastructure/persistence/UsuarioRepositoryPg.ts"
      via: "instantiated and passed to AutenticarUsuario use case"
      pattern: "UsuarioRepositoryPg"
---

<objective>
Implement all PostgreSQL repository adapters, JWT auth service, bcrypt hash service, and wire them into the application entrypoint — replacing all stubs with real implementations.

Purpose: This bridges the domain layer with actual persistence and auth infrastructure, making the API functional end-to-end.
Output: 5 repository adapters, 2 auth services, 1 certificate store, updated index.ts with real wiring.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-infrastructure-testing/08-01-SUMMARY.md

Domain ports to implement:
@nandefact-api/src/domain/factura/IFacturaRepository.ts
@nandefact-api/src/domain/comercio/IComercioRepository.ts
@nandefact-api/src/domain/cliente/IClienteRepository.ts
@nandefact-api/src/domain/producto/IProductoRepository.ts
@nandefact-api/src/domain/usuario/IUsuarioRepository.ts
@nandefact-api/src/domain/auth/IAuthService.ts
@nandefact-api/src/domain/auth/IHashService.ts
@nandefact-api/src/domain/comercio/ICertificadoStore.ts

Domain entities for mapping:
@nandefact-api/src/domain/factura/Factura.ts
@nandefact-api/src/domain/factura/ItemFactura.ts
@nandefact-api/src/domain/comercio/Comercio.ts
@nandefact-api/src/domain/cliente/Cliente.ts
@nandefact-api/src/domain/producto/Producto.ts
@nandefact-api/src/domain/usuario/Usuario.ts
@nandefact-api/src/domain/comercio/RUC.ts
@nandefact-api/src/domain/comercio/Timbrado.ts
@nandefact-api/src/domain/factura/CDC.ts
@nandefact-api/src/domain/factura/NumeroFactura.ts
@nandefact-api/src/domain/shared/types.ts

Current stubs to replace:
@nandefact-api/src/index.ts

Prisma client (from 08-01):
@nandefact-api/src/infrastructure/persistence/prismaClient.ts
@nandefact-api/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PostgreSQL repository adapters for all 5 entities</name>
  <files>
    nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/UsuarioRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/ProductoRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/ClienteRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/CertificadoStorePg.ts
  </files>
  <action>
    Each adapter follows the same pattern:
    1. Constructor takes PrismaClient instance
    2. Implements domain port interface exactly
    3. Maps domain entity <-> Prisma model (toDomain / toPrisma helper functions)
    4. Uses parametrized queries via Prisma (safe from SQL injection)

    **ComercioRepositoryPg** (implements IComercioRepository):
    - `save(comercio)`: Upsert by id. Map domain Comercio -> Prisma: decompose RUC value object to ruc string, decompose Timbrado to timbradoNumero/timbradoFechaInicio/timbradoFechaFin, map tipoContribuyente (1/2) to Int.
    - `findById(id)`: Find by id, return null if not found. Map back: reconstruct RUC from ruc string, reconstruct Timbrado from timbrado fields.
    - `findByRuc(ruc)`: Find by ruc field (unique), reconstruct domain entity.
    - Private `toDomain(prismaComercio)`: Reconstruct Comercio with all value objects.
    - Private `toPrisma(comercio)`: Flatten Comercio to Prisma fields.

    **UsuarioRepositoryPg** (implements IUsuarioRepository):
    - `save(usuario)`: Upsert by id. Map rol: domain 'dueño' -> Prisma enum 'dueno', domain 'empleado' -> 'empleado'.
    - `findById(id)`: Find by id, reconstruct Usuario.
    - `findByTelefono(telefono)`: Find by telefono (unique), reconstruct.
    - Map bloqueadoHasta DateTime? <-> Date | null.

    **ProductoRepositoryPg** (implements IProductoRepository):
    - `save(producto)`: Upsert by id. Map precioUnitario: number -> BigInt. Map tasaIVA: 10/5/0 -> Int.
    - `findById(id)`: Find, map BigInt -> number for precioUnitario.
    - `findByComercio(comercioId, options?)`: Paginated query with skip/take. Filter by activo if soloActivos=true. Return `{ productos, total }` where total is `count()`.

    **ClienteRepositoryPg** (implements IClienteRepository):
    - `save(cliente)`: Upsert by id.
    - `findById(id)`: Standard find + domain mapping.
    - `findByComercio(comercioId)`: Find all by comercioId.
    - `buscar(comercioId, query)`: Use Prisma `contains` (case-insensitive) on nombre, rucCi fields. Filter by comercioId. Limit to 20 results.

    **FacturaRepositoryPg** (implements IFacturaRepository) — MOST COMPLEX:
    - `save(factura)`: Upsert factura + upsert all detalles (delete existing detalles, create new). Wrap in transaction. Map: all monetary fields (totalBruto, etc.) from number -> BigInt. Map CDC value object to string. Map NumeroFactura value object to separate fields (establecimiento, puntoExpedicion, numero as BigInt). Map items: create FacturaDetalle records from ItemFactura instances. Map Timbrado to timbradoNumero/timbradoFechaInicio/timbradoFechaFin.
    - `findById(id)`: Include detalles. Reconstruct via `Factura.fromPersistence()`.
    - `findByComercio(comercioId)`: Include detalles, ordered by createdAt desc.
    - `findPendientes(comercioId)`: Filter by estadoSifen = 'pendiente', include detalles.
    - Private `toDomain(prismaFactura)`: Uses `Factura.fromPersistence()` for reconstruction (see below).

    **DEFINITIVE Factura reconstruction strategy — `Factura.fromPersistence()` factory method:**
    Add a static method to the Factura class in `src/domain/factura/Factura.ts`:
    ```typescript
    static fromPersistence(props: FacturaProps & {
      items: ItemFactura[];
      cdc: CDC | null;
      estado: EstadoSifen;
      totalBruto: number;
      totalIVA10: number;
      totalIVA5: number;
      totalExenta: number;
      totalIVA: number;
    }): Factura {
      // Bypass timbrado vigencia validation — data was valid at creation time
      const factura = Object.create(Factura.prototype) as Factura;
      Object.assign(factura, {
        id: props.id,
        comercioId: props.comercioId,
        clienteId: props.clienteId,
        tipoDocumento: props.tipoDocumento,
        timbrado: props.timbrado,
        numeroFactura: props.numeroFactura,
        tipoEmision: props.tipoEmision,
        condicionPago: props.condicionPago,
        fechaEmision: props.fechaEmision,
        _items: props.items,
        _cdc: props.cdc,
        _estado: props.estado,
        _totalBruto: props.totalBruto,
        _totalIVA10: props.totalIVA10,
        _totalIVA5: props.totalIVA5,
        _totalExenta: props.totalExenta,
        _totalIVA: props.totalIVA,
      });
      return factura;
    }
    ```
    This approach is chosen because:
    1. It bypasses the constructor's `timbrado.validarVigencia()` call, which would fail for expired timbrados on historical facturas
    2. It directly sets private fields (`_estado`, `_cdc`, `_items`, totals) without walking the state machine
    3. It keeps the normal constructor strict for new facturas
    4. The `toDomain()` mapper in FacturaRepositoryPg calls `Factura.fromPersistence()` with all fields from DB

    **IMPORTANT BigInt handling:** Prisma returns BigInt for BigInt columns. Convert to Number via `Number(bigintValue)` when mapping to domain. Convert domain number to BigInt via `BigInt(numberValue)` when saving. PYG values fit safely in Number (max ~9 quadrillion, well within Number.MAX_SAFE_INTEGER).

    **CertificadoStorePg** (implements ICertificadoStore):
    - Uses Comercio table's ccfeCertificado and ccfeClave fields.
    - `guardar(comercioId, pkcs12, password)`: Encrypt pkcs12 and password with AES-256 using CCFE_ENCRYPTION_KEY env var, store in comercio record.
    - `recuperar(comercioId)`: Load, decrypt, return.
    - `existe(comercioId)`: Check if ccfeCertificado is not null.
    - Use Node.js crypto module for AES-256-GCM encryption/decryption.
  </action>
  <verify>
    - `tsc --noEmit` passes — all adapters compile with correct types
    - `npm test` passes — existing 359 tests unaffected
    - Each adapter file exports a class implementing the correct port interface
  </verify>
  <done>
    All 5 repository adapters + CertificadoStorePg implement their domain port interfaces with proper entity <-> Prisma mapping. BigInt conversion handled. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement AuthServiceJWT + HashServiceBcrypt + wire index.ts</name>
  <files>
    nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts
    nandefact-api/src/infrastructure/auth/HashServiceBcrypt.ts
    nandefact-api/package.json
    nandefact-api/src/index.ts
  </files>
  <action>
    1. Install dependencies:
       - `npm install jsonwebtoken bcrypt`
       - `npm install -D @types/jsonwebtoken @types/bcrypt`

    2. **AuthServiceJWT** (implements IAuthService):
       - Constructor takes `{ accessSecret: string, refreshSecret: string, accessExpiresIn?: number, refreshExpiresIn?: number }`.
       - Defaults: accessExpiresIn = 900 (15 min), refreshExpiresIn = 604800 (7 days).
       - `generarTokens(payload)`: Sign access token with accessSecret (expiresIn: accessExpiresIn), sign refresh token with refreshSecret (expiresIn: refreshExpiresIn). Return `{ accessToken, refreshToken, expiresIn: accessExpiresIn }`.
       - `verificarAccessToken(token)`: Verify with accessSecret, return decoded payload as TokenPayload.
       - `verificarRefreshToken(token)`: Verify with refreshSecret, return decoded payload.
       - Use `jwt.sign()` and `jwt.verify()` from jsonwebtoken.
       - Handle expired/invalid tokens by throwing Error.
       - **CommonJS import handling:** jsonwebtoken is CommonJS. Use `import jwt from 'jsonwebtoken'` — this works because tsconfig.json has `esModuleInterop: true`. Verify by running `tsc --noEmit` after creating the file. If it fails, fall back to `import * as jwt from 'jsonwebtoken'` or dynamic import `const jwt = (await import('jsonwebtoken')).default`.

    3. **HashServiceBcrypt** (implements IHashService):
       - `hash(pin)`: Use `bcrypt.hash(pin, 10)` (10 salt rounds).
       - `verificar(pin, hash)`: Use `bcrypt.compare(pin, hash)`.
       - **CommonJS import handling:** bcrypt is CommonJS. Use `import bcrypt from 'bcrypt'` — this works because tsconfig.json has `esModuleInterop: true`. Same fallback strategy as jsonwebtoken if compilation fails.

    4. **Update index.ts** — Replace ALL stubs with real implementations:
       - Import PrismaClient from persistence/prismaClient.ts
       - Import all repository adapters (ComercioRepositoryPg, etc.)
       - Import AuthServiceJWT and HashServiceBcrypt
       - Import CertificadoStorePg
       - Import real SIFEN adapters (XmlGeneratorSifen, FirmaDigitalSifen, SifenGatewayImpl already exist)
       - Import SyncQueueBullMQ, KudeGeneratorImpl, NotificadorStub, ConsoleLogger (already exist)
       - Read config from env: DATABASE_URL, JWT_SECRET, JWT_REFRESH_SECRET, REDIS_URL, CCFE_ENCRYPTION_KEY
       - Instantiate real dependencies:
         ```
         const prisma = new PrismaClient() (or import singleton)
         const authService = new AuthServiceJWT({ accessSecret: JWT_SECRET, refreshSecret: JWT_REFRESH_SECRET })
         const hashService = new HashServiceBcrypt()
         const facturaRepository = new FacturaRepositoryPg(prisma)
         const comercioRepository = new ComercioRepositoryPg(prisma)
         const clienteRepository = new ClienteRepositoryPg(prisma)
         const productoRepository = new ProductoRepositoryPg(prisma)
         const usuarioRepository = new UsuarioRepositoryPg(prisma)
         const certificadoStore = new CertificadoStorePg(prisma, CCFE_ENCRYPTION_KEY)
         // SIFEN adapters (already implemented, use them)
         const xmlGenerator = new XmlGeneratorSifen()
         const firmaDigital = new FirmaDigitalSifen()
         const sifenGateway = new SifenGatewayImpl(sifenConfig)
         const kudeGenerator = new KudeGeneratorImpl(qrGenerator)
         const notificador = new NotificadorStub()
         // Queue
         const syncQueue = new SyncQueueBullMQ(redisConnection)
         ```
       - Wire use cases with real dependencies (replace stub wiring). Explicit wiring for all use cases:
         ```
         // Auth use cases — need UsuarioRepositoryPg explicitly
         const usuarioRepository = new UsuarioRepositoryPg(prisma)
         const autenticarUsuario = new AutenticarUsuario(usuarioRepository, hashService, authService)
         const refrescarToken = new RefrescarToken(authService)

         // Facturacion use cases
         const crearFactura = new CrearFactura(facturaRepository, productoRepository, comercioRepository)
         const enviarDE = new EnviarDE(facturaRepository, comercioRepository, clienteRepository, xmlGenerator, firmaDigital, sifenGateway, certificadoStore)
         // ... etc for remaining use cases
         ```
       - Remove ALL Stub classes
       - Keep graceful shutdown: disconnect Prisma on SIGTERM/SIGINT
       - Handle missing env vars gracefully: if JWT_SECRET not set, use a dev default with console warning.
  </action>
  <verify>
    - `tsc --noEmit` passes — index.ts compiles with real adapters
    - `npm test` passes — existing 359 tests unaffected
    - `npm run lint` passes or only has pre-existing warnings
    - No Stub classes remain in index.ts
  </verify>
  <done>
    AuthServiceJWT and HashServiceBcrypt implement their ports. index.ts wires all real adapters (no more stubs). Application can start with `npm run dev` when PostgreSQL + Redis are available.
  </done>
</task>

</tasks>

<verification>
1. `tsc --noEmit` — all new files compile correctly
2. `npm test` — existing 359 tests still pass
3. `grep -r "StubAuthService\|StubFacturaRepository\|StubComercioRepository" src/index.ts` returns no results (stubs removed)
4. Each repository adapter exports a class implementing the correct port interface
5. AuthServiceJWT can generate and verify tokens (verified in Phase 08-03 integration tests)
</verification>

<success_criteria>
- 5 repository adapters (Comercio, Usuario, Producto, Cliente, Factura) implement domain ports with Prisma
- AuthServiceJWT generates access (15min) + refresh (7d) tokens and verifies them
- HashServiceBcrypt hashes and verifies PINs with bcrypt
- CertificadoStorePg encrypts/decrypts with AES-256
- index.ts uses real implementations, zero stubs remain
- All existing 359 unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-infrastructure-testing/08-02-SUMMARY.md`
</output>
