---
phase: 08-infrastructure-testing
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/UsuarioRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/ProductoRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/ClienteRepositoryPg.ts
  - nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts
  - nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts
  - nandefact-api/src/infrastructure/auth/HashServiceBcrypt.ts
  - nandefact-api/src/infrastructure/persistence/CertificadoStorePg.ts
  - nandefact-api/src/index.ts
autonomous: true

must_haves:
  truths:
    - "All 5 repository adapters implement their domain port interfaces with real Prisma queries"
    - "AuthServiceJWT generates and verifies JWT tokens with 15min access / 7day refresh"
    - "HashServiceBcrypt hashes and verifies PINs using bcrypt"
    - "index.ts uses real implementations instead of stubs when DATABASE_URL is set"
    - "Domain entity <-> Prisma model mapping is correct for all entities including value objects (RUC, Timbrado, CDC, NumeroFactura, MontoIVA)"
  artifacts:
    - path: "nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts"
      provides: "PostgreSQL adapter for IComercioRepository"
      exports: ["ComercioRepositoryPg"]
    - path: "nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts"
      provides: "PostgreSQL adapter for IFacturaRepository with items mapping"
      exports: ["FacturaRepositoryPg"]
    - path: "nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts"
      provides: "JWT token generation and verification"
      exports: ["AuthServiceJWT"]
    - path: "nandefact-api/src/infrastructure/auth/HashServiceBcrypt.ts"
      provides: "Bcrypt PIN hashing"
      exports: ["HashServiceBcrypt"]
    - path: "nandefact-api/src/index.ts"
      provides: "Wired application with real adapters"
      contains: "RepositoryPg"
  key_links:
    - from: "nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts"
      to: "nandefact-api/src/domain/factura/IFacturaRepository.ts"
      via: "implements IFacturaRepository"
      pattern: "implements IFacturaRepository"
    - from: "nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts"
      to: "nandefact-api/src/domain/auth/IAuthService.ts"
      via: "implements IAuthService"
      pattern: "implements IAuthService"
    - from: "nandefact-api/src/index.ts"
      to: "nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts"
      via: "import and instantiation"
      pattern: "ComercioRepositoryPg"
---

<objective>
Implement all PostgreSQL repository adapters, JWT auth service, bcrypt hash service, and wire them into the application entrypoint — replacing all stubs with real implementations.

Purpose: This bridges the domain layer with actual persistence and auth infrastructure, making the API functional end-to-end.
Output: 5 repository adapters, 2 auth services, 1 certificate store, updated index.ts with real wiring.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-infrastructure-testing/08-01-SUMMARY.md

Domain ports to implement:
@nandefact-api/src/domain/factura/IFacturaRepository.ts
@nandefact-api/src/domain/comercio/IComercioRepository.ts
@nandefact-api/src/domain/cliente/IClienteRepository.ts
@nandefact-api/src/domain/producto/IProductoRepository.ts
@nandefact-api/src/domain/usuario/IUsuarioRepository.ts
@nandefact-api/src/domain/auth/IAuthService.ts
@nandefact-api/src/domain/auth/IHashService.ts
@nandefact-api/src/domain/comercio/ICertificadoStore.ts

Domain entities for mapping:
@nandefact-api/src/domain/factura/Factura.ts
@nandefact-api/src/domain/factura/ItemFactura.ts
@nandefact-api/src/domain/comercio/Comercio.ts
@nandefact-api/src/domain/cliente/Cliente.ts
@nandefact-api/src/domain/producto/Producto.ts
@nandefact-api/src/domain/usuario/Usuario.ts
@nandefact-api/src/domain/comercio/RUC.ts
@nandefact-api/src/domain/comercio/Timbrado.ts
@nandefact-api/src/domain/factura/CDC.ts
@nandefact-api/src/domain/factura/NumeroFactura.ts
@nandefact-api/src/domain/shared/types.ts

Current stubs to replace:
@nandefact-api/src/index.ts

Prisma client (from 08-01):
@nandefact-api/src/infrastructure/persistence/prismaClient.ts
@nandefact-api/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PostgreSQL repository adapters for all 5 entities</name>
  <files>
    nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/UsuarioRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/ProductoRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/ClienteRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts
    nandefact-api/src/infrastructure/persistence/CertificadoStorePg.ts
  </files>
  <action>
    Each adapter follows the same pattern:
    1. Constructor takes PrismaClient instance
    2. Implements domain port interface exactly
    3. Maps domain entity <-> Prisma model (toDomain / toPrisma helper functions)
    4. Uses parametrized queries via Prisma (safe from SQL injection)

    **ComercioRepositoryPg** (implements IComercioRepository):
    - `save(comercio)`: Upsert by id. Map domain Comercio -> Prisma: decompose RUC value object to ruc string, decompose Timbrado to timbradoNumero/timbradoFechaInicio/timbradoFechaFin, map tipoContribuyente (1/2) to Int.
    - `findById(id)`: Find by id, return null if not found. Map back: reconstruct RUC from ruc string, reconstruct Timbrado from timbrado fields.
    - `findByRuc(ruc)`: Find by ruc field (unique), reconstruct domain entity.
    - Private `toDomain(prismaComercio)`: Reconstruct Comercio with all value objects.
    - Private `toPrisma(comercio)`: Flatten Comercio to Prisma fields.

    **UsuarioRepositoryPg** (implements IUsuarioRepository):
    - `save(usuario)`: Upsert by id. Map rol: domain 'dueño' -> Prisma enum 'dueno', domain 'empleado' -> 'empleado'.
    - `findById(id)`: Find by id, reconstruct Usuario.
    - `findByTelefono(telefono)`: Find by telefono (unique), reconstruct.
    - Map bloqueadoHasta DateTime? <-> Date | null.

    **ProductoRepositoryPg** (implements IProductoRepository):
    - `save(producto)`: Upsert by id. Map precioUnitario: number -> BigInt. Map tasaIVA: 10/5/0 -> Int.
    - `findById(id)`: Find, map BigInt -> number for precioUnitario.
    - `findByComercio(comercioId, options?)`: Paginated query with skip/take. Filter by activo if soloActivos=true. Return `{ productos, total }` where total is `count()`.

    **ClienteRepositoryPg** (implements IClienteRepository):
    - `save(cliente)`: Upsert by id.
    - `findById(id)`: Standard find + domain mapping.
    - `findByComercio(comercioId)`: Find all by comercioId.
    - `buscar(comercioId, query)`: Use Prisma `contains` (case-insensitive) on nombre, rucCi fields. Filter by comercioId. Limit to 20 results.

    **FacturaRepositoryPg** (implements IFacturaRepository) — MOST COMPLEX:
    - `save(factura)`: Upsert factura + upsert all detalles (delete existing detalles, create new). Wrap in transaction. Map: all monetary fields (totalBruto, etc.) from number -> BigInt. Map CDC value object to string. Map NumeroFactura value object to separate fields (establecimiento, puntoExpedicion, numero as BigInt). Map items: create FacturaDetalle records from ItemFactura instances. Map Timbrado to timbradoNumero/timbradoFechaInicio/timbradoFechaFin.
    - `findById(id)`: Include detalles. Reconstruct: create Factura, add items via agregarItem, restore estado. **Important:** Factura constructor validates timbrado vigencia on construction, but when loading from DB the factura was already created at a valid time. Need to handle this: either skip validation on reconstruction or provide a static factory method `fromPersistence()`. Solution: Create Factura with the original fechaEmision (which was valid at creation time) — the Timbrado constructor validates fechaInicio < fechaFin, and validarVigencia checks fechaEmision is within range, which should still hold.
    - `findByComercio(comercioId)`: Include detalles, ordered by createdAt desc.
    - `findPendientes(comercioId)`: Filter by estadoSifen = 'pendiente', include detalles.
    - Private `toDomain(prismaFactura)`: Complex reconstruction — create Factura with original props, add items, set CDC if present, set estado. Need to handle the private fields: after constructing Factura and adding items, use a pattern to set internal state (e.g., Object.assign or a static `reconstruct` factory method on Factura). **Recommended approach**: Add a static `fromPersistence(props & { items, cdc, estado })` method to Factura class that bypasses normal construction flow for DB loading. Alternatively, add items via `agregarItem()` and then set estado via the state machine methods (marcarEnviada, etc.) in sequence. The simplest approach: after creating the Factura and calling agregarItem for each item, walk the state machine from 'pendiente' to the target state by calling transition methods in sequence. For CDC, add a `restaurarCDC(cdc: CDC)` method or use Object.assign.

    **IMPORTANT BigInt handling:** Prisma returns BigInt for BigInt columns. Convert to Number via `Number(bigintValue)` when mapping to domain. Convert domain number to BigInt via `BigInt(numberValue)` when saving. PYG values fit safely in Number (max ~9 quadrillion, well within Number.MAX_SAFE_INTEGER).

    **CertificadoStorePg** (implements ICertificadoStore):
    - Uses Comercio table's ccfeCertificado and ccfeClave fields.
    - `guardar(comercioId, pkcs12, password)`: Encrypt pkcs12 and password with AES-256 using CCFE_ENCRYPTION_KEY env var, store in comercio record.
    - `recuperar(comercioId)`: Load, decrypt, return.
    - `existe(comercioId)`: Check if ccfeCertificado is not null.
    - Use Node.js crypto module for AES-256-GCM encryption/decryption.
  </action>
  <verify>
    - `tsc --noEmit` passes — all adapters compile with correct types
    - `npm test` passes — existing 359 tests unaffected
    - Each adapter file exports a class implementing the correct port interface
  </verify>
  <done>
    All 5 repository adapters + CertificadoStorePg implement their domain port interfaces with proper entity <-> Prisma mapping. BigInt conversion handled. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement AuthServiceJWT + HashServiceBcrypt + wire index.ts</name>
  <files>
    nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts
    nandefact-api/src/infrastructure/auth/HashServiceBcrypt.ts
    nandefact-api/package.json
    nandefact-api/src/index.ts
  </files>
  <action>
    1. Install dependencies:
       - `npm install jsonwebtoken bcrypt`
       - `npm install -D @types/jsonwebtoken @types/bcrypt`

    2. **AuthServiceJWT** (implements IAuthService):
       - Constructor takes `{ accessSecret: string, refreshSecret: string, accessExpiresIn?: number, refreshExpiresIn?: number }`.
       - Defaults: accessExpiresIn = 900 (15 min), refreshExpiresIn = 604800 (7 days).
       - `generarTokens(payload)`: Sign access token with accessSecret (expiresIn: accessExpiresIn), sign refresh token with refreshSecret (expiresIn: refreshExpiresIn). Return `{ accessToken, refreshToken, expiresIn: accessExpiresIn }`.
       - `verificarAccessToken(token)`: Verify with accessSecret, return decoded payload as TokenPayload.
       - `verificarRefreshToken(token)`: Verify with refreshSecret, return decoded payload.
       - Use `jwt.sign()` and `jwt.verify()` from jsonwebtoken.
       - Handle expired/invalid tokens by throwing Error.
       - Note: jsonwebtoken is CommonJS. Use `import jwt from 'jsonwebtoken'` with esModuleInterop.

    3. **HashServiceBcrypt** (implements IHashService):
       - `hash(pin)`: Use `bcrypt.hash(pin, 10)` (10 salt rounds).
       - `verificar(pin, hash)`: Use `bcrypt.compare(pin, hash)`.
       - Note: bcrypt is CommonJS. Use `import bcrypt from 'bcrypt'` with esModuleInterop.

    4. **Update index.ts** — Replace ALL stubs with real implementations:
       - Import PrismaClient from persistence/prismaClient.ts
       - Import all repository adapters (ComercioRepositoryPg, etc.)
       - Import AuthServiceJWT and HashServiceBcrypt
       - Import CertificadoStorePg
       - Import real SIFEN adapters (XmlGeneratorSifen, FirmaDigitalSifen, SifenGatewayImpl already exist)
       - Import SyncQueueBullMQ, KudeGeneratorImpl, NotificadorStub, ConsoleLogger (already exist)
       - Read config from env: DATABASE_URL, JWT_SECRET, JWT_REFRESH_SECRET, REDIS_URL, CCFE_ENCRYPTION_KEY
       - Instantiate real dependencies:
         ```
         const prisma = new PrismaClient() (or import singleton)
         const authService = new AuthServiceJWT({ accessSecret: JWT_SECRET, refreshSecret: JWT_REFRESH_SECRET })
         const hashService = new HashServiceBcrypt()
         const facturaRepository = new FacturaRepositoryPg(prisma)
         const comercioRepository = new ComercioRepositoryPg(prisma)
         const clienteRepository = new ClienteRepositoryPg(prisma)
         const productoRepository = new ProductoRepositoryPg(prisma)
         const usuarioRepository = new UsuarioRepositoryPg(prisma)
         const certificadoStore = new CertificadoStorePg(prisma, CCFE_ENCRYPTION_KEY)
         // SIFEN adapters (already implemented, use them)
         const xmlGenerator = new XmlGeneratorSifen()
         const firmaDigital = new FirmaDigitalSifen()
         const sifenGateway = new SifenGatewayImpl(sifenConfig)
         const kudeGenerator = new KudeGeneratorImpl(qrGenerator)
         const notificador = new NotificadorStub()
         // Queue
         const syncQueue = new SyncQueueBullMQ(redisConnection)
         ```
       - Wire use cases with real dependencies (replace stub wiring)
       - Remove ALL Stub classes
       - Keep graceful shutdown: disconnect Prisma on SIGTERM/SIGINT
       - The AutenticarUsuario use case needs both IUsuarioRepository and IHashService and IAuthService — check its constructor signature and wire accordingly.
       - The RefrescarToken use case needs IAuthService — wire accordingly.
       - Handle missing env vars gracefully: if JWT_SECRET not set, use a dev default with console warning.
  </action>
  <verify>
    - `tsc --noEmit` passes — index.ts compiles with real adapters
    - `npm test` passes — existing 359 tests unaffected
    - `npm run lint` passes or only has pre-existing warnings
    - No Stub classes remain in index.ts
  </verify>
  <done>
    AuthServiceJWT and HashServiceBcrypt implement their ports. index.ts wires all real adapters (no more stubs). Application can start with `npm run dev` when PostgreSQL + Redis are available.
  </done>
</task>

</tasks>

<verification>
1. `tsc --noEmit` — all new files compile correctly
2. `npm test` — existing 359 tests still pass
3. `grep -r "StubAuthService\|StubFacturaRepository\|StubComercioRepository" src/index.ts` returns no results (stubs removed)
4. Each repository adapter exports a class implementing the correct port interface
5. AuthServiceJWT can generate and verify tokens (verified in Phase 08-03 integration tests)
</verification>

<success_criteria>
- 5 repository adapters (Comercio, Usuario, Producto, Cliente, Factura) implement domain ports with Prisma
- AuthServiceJWT generates access (15min) + refresh (7d) tokens and verifies them
- HashServiceBcrypt hashes and verifies PINs with bcrypt
- CertificadoStorePg encrypts/decrypts with AES-256
- index.ts uses real implementations, zero stubs remain
- All existing 359 unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-infrastructure-testing/08-02-SUMMARY.md`
</output>
