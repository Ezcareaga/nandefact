---
phase: 08-infrastructure-testing
plan: 04
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - nandefact-api/tests/e2e/facturaFlow.test.ts
  - nandefact-api/tests/e2e/helpers/testServer.ts
  - nandefact-api/docker-compose.test.yml
  - nandefact-api/package.json
autonomous: true

must_haves:
  truths:
    - "E2E test completes full flow: create factura -> sign XML -> mock SIFEN response -> update estado to aprobado"
    - "E2E test uses real PostgreSQL, real Express server, real repository adapters"
    - "SIFEN gateway is mocked (certificate not available) but all other layers are real"
    - "Test can be run with npm run test:e2e in Docker environment"
    - "docker-compose.test.yml provides isolated test environment"
  artifacts:
    - path: "nandefact-api/tests/e2e/facturaFlow.test.ts"
      provides: "End-to-end test of the core invoicing flow"
      contains: "factura"
    - path: "nandefact-api/tests/e2e/helpers/testServer.ts"
      provides: "Test server bootstrap with real adapters + mock SIFEN"
      exports: ["createTestServer"]
    - path: "nandefact-api/docker-compose.test.yml"
      provides: "Docker Compose for CI/test environment"
      contains: "postgres"
  key_links:
    - from: "nandefact-api/tests/e2e/facturaFlow.test.ts"
      to: "nandefact-api/tests/e2e/helpers/testServer.ts"
      via: "imports createTestServer for HTTP testing"
      pattern: "createTestServer"
    - from: "nandefact-api/tests/e2e/helpers/testServer.ts"
      to: "nandefact-api/src/interfaces/http/server.ts"
      via: "creates real Express app with real adapters"
      pattern: "createApp|startServer"
---

<objective>
Create an end-to-end test that exercises the full invoicing flow through the real HTTP layer, real PostgreSQL, and real adapters — only mocking the SIFEN SOAP gateway (certificate not available). Also create a Docker Compose test configuration for CI.

Purpose: Verify the entire system works together, from HTTP request to database persistence, following the core user journey.
Output: E2E test file, test server helper, Docker Compose test config, npm scripts.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-infrastructure-testing/08-01-SUMMARY.md
@.planning/phases/08-infrastructure-testing/08-02-SUMMARY.md

HTTP layer:
@nandefact-api/src/interfaces/http/server.ts
@nandefact-api/src/interfaces/http/app.ts
@nandefact-api/src/interfaces/http/routes/authRoutes.ts
@nandefact-api/src/interfaces/http/routes/facturaRoutes.ts
@nandefact-api/src/interfaces/http/routes/productoRoutes.ts
@nandefact-api/src/interfaces/http/routes/clienteRoutes.ts
@nandefact-api/src/interfaces/http/routes/comercioRoutes.ts

Application wiring:
@nandefact-api/src/index.ts

Domain entities:
@nandefact-api/src/domain/factura/Factura.ts
@nandefact-api/src/domain/shared/types.ts

Test infrastructure (from 08-03):
@nandefact-api/tests/integration/helpers/testDb.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test server helper + E2E factura flow test</name>
  <files>
    nandefact-api/tests/e2e/helpers/testServer.ts
    nandefact-api/tests/e2e/facturaFlow.test.ts
    nandefact-api/package.json
  </files>
  <action>
    1. **Install supertest** for HTTP testing:
       - `npm install -D supertest @types/supertest`
       - supertest is the standard Express testing library (listed in CLAUDE.md stack) and provides clean syntax for HTTP assertions.

    2. Add `"test:e2e": "vitest run tests/e2e/"` to package.json scripts.
       Also add `"test:all": "vitest run"` that runs everything (unit + integration + e2e).

    3. **Create `tests/e2e/helpers/testServer.ts`:**
       - Creates a fully-wired Express app with REAL adapters for everything EXCEPT SIFEN gateway.
       - Uses real PrismaClient (test database), real AuthServiceJWT, real HashServiceBcrypt, real repository adapters.
       - Mocks SIFEN gateway: `ISifenGateway` that returns aprobado response (code 0260) for `enviarDE()`, success for `anularDE()`, valid RUC for `consultarRUC()`.
       - Mocks XML generator and firma digital: return placeholder XML/signed XML strings.
       - Uses NotificadorStub (already exists, fine for e2e).
       - For queue: Use a simple in-memory mock or SyncQueueBullMQ with mock Redis (depending on complexity). Simplest: mock ISyncQueue that immediately processes.
       - Exports:
         - `createTestServer()`: Returns `{ app: Express, server: Server, prisma: PrismaClient, cleanup: () => Promise<void> }`.
         - `cleanup()` closes server, disconnects prisma, cleans database.
       - Helper: `getAuthToken(app, comercioId, usuarioId, rol)`: Generates a valid JWT for testing authenticated endpoints.

    4. **Create `tests/e2e/facturaFlow.test.ts`:**
       The test follows the core user journey described in CLAUDE.md:

       **Setup (beforeAll):**
       - Start test server via `createTestServer()`
       - **Test seeding strategy:** Seed directly via Prisma client (from `createTestServer().prisma`) using `prisma.comercio.create()`, `prisma.usuario.create()`, etc. Do NOT use the HTTP API for seeding — seed data must exist before testing endpoints. Use the same test factory helpers from `tests/integration/helpers/testDb.ts` if available, or create Prisma records directly.
       - Seed database with:
         a) A comercio (Almacén Doña María, RUC 80069563-1, timbrado vigente, establecimiento 001, punto 003) — via `prisma.comercio.create({ data: {...} })`
         b) A usuario (dueño, teléfono +595981234567, PIN hash for "1234") — hash the PIN using HashServiceBcrypt before inserting, via `prisma.usuario.create({ data: {...} })`
         c) 3 productos (Mandioca Gs 5000/kg IVA 5%, Arroz Gs 8000/kg IVA 10%, Aceite Gs 15000/un IVA 10%) — via `prisma.producto.createMany()`
         d) A cliente (Juan Pérez, CI 4567890) — via `prisma.cliente.create({ data: {...} })`

       **Test cases (~8-12 tests):**

       a) `POST /api/v1/auth/login — authenticates with teléfono + PIN`:
          - POST with { telefono: "+595981234567", pin: "1234" }
          - Expect 200 with { success: true, data: { accessToken, refreshToken, expiresIn } }
          - Save accessToken for subsequent requests

       b) `POST /api/v1/facturas — creates factura`:
          - POST with Authorization header (Bearer token)
          - Body: { clienteId, tipoDocumento: 1, condicionPago: "contado", items: [{ productoId, cantidad: 3 }, { productoId2, cantidad: 2 }] }
          - Expect 201 with factura data including CDC, totals, estado "pendiente"
          - Save facturaId

       c) `GET /api/v1/facturas/:id — retrieves created factura`:
          - GET with auth token
          - Expect 200 with complete factura including items, totals, CDC
          - Verify totalBruto matches expected calculation

       d) `GET /api/v1/facturas — lists facturas with pagination`:
          - GET with auth token
          - Expect 200 with array containing the created factura
          - Verify pagination info

       e) `POST /api/v1/productos — creates a new producto`:
          - POST with auth token
          - Body: { nombre: "Chipas", precioUnitario: 3000, unidadMedida: "UN", tasaIVA: 10 }
          - Expect 201 with created producto

       f) `GET /api/v1/productos — lists productos`:
          - GET with auth token
          - Expect 200 with paginated list including seeded + new producto

       g) `POST /api/v1/clientes — creates a new cliente`:
          - POST with auth token
          - Body: { nombre: "María López", rucCi: "1234567-8", tipoDocumento: "RUC" }
          - Expect 201

       h) `GET /api/v1/clientes/buscar?q=Juan — searches clientes`:
          - GET with auth token
          - Expect 200 with array containing Juan Pérez

       i) `POST /api/v1/auth/refresh — refreshes tokens`:
          - POST with refreshToken from login
          - Expect 200 with new token pair

       j) `GET /health — returns ok without auth`:
          - GET without auth
          - Expect 200 with { status: "ok" }

       **Teardown (afterAll):**
       - Call cleanup() to close server, clean DB, disconnect

    5. **HTTP request helper:**
       Use `supertest` (installed in step 1) for all HTTP assertions. Import as `import request from 'supertest'` and use `request(app).get('/path')` pattern. supertest handles port binding automatically — no need to listen on a random port manually.
  </action>
  <verify>
    - `docker compose up -d postgres redis` — services running
    - `DATABASE_URL=... npx prisma migrate dev` — tables created
    - `npm run test:e2e` — all e2e tests pass
    - `npm test` — unit tests (359) still pass
    - `npm run test:integration` — integration tests still pass (if 08-03 completed)
  </verify>
  <done>
    E2E test exercises full invoicing flow: login -> create factura -> verify persistence -> list/search. Test server uses real adapters with mocked SIFEN. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Docker Compose test config + CI test script</name>
  <files>
    nandefact-api/docker-compose.test.yml
    nandefact-api/scripts/test-ci.sh
    nandefact-api/package.json
  </files>
  <action>
    1. **Create `docker-compose.test.yml`:**
       Isolated test environment that does NOT conflict with development:
       ```yaml
       # Test environment — isolated from development
       services:
         postgres-test:
           image: postgres:16-alpine
           container_name: nandefact-postgres-test
           ports:
             - '5433:5432'  # Different port to avoid conflict with dev
           environment:
             POSTGRES_USER: nandefact_test
             POSTGRES_PASSWORD: nandefact_test
             POSTGRES_DB: nandefact_test
           tmpfs:
             - /var/lib/postgresql/data  # In-memory for speed, data lost on stop
           healthcheck:
             test: ['CMD-SHELL', 'pg_isready -U nandefact_test']
             interval: 5s
             timeout: 3s
             retries: 10

         redis-test:
           image: redis:7-alpine
           container_name: nandefact-redis-test
           ports:
             - '6380:6379'  # Different port
           healthcheck:
             test: ['CMD', 'redis-cli', 'ping']
             interval: 5s
             timeout: 3s
             retries: 10
       ```

       Key differences from dev compose:
       - Different container names (avoid conflicts)
       - Different host ports (5433, 6380)
       - tmpfs for PostgreSQL (fast, ephemeral — perfect for CI)
       - Faster health check intervals

    2. **Create `scripts/test-ci.sh`:**
       ```bash
       #!/bin/bash
       set -e

       echo "Starting test infrastructure..."
       docker compose -f docker-compose.test.yml up -d --wait

       echo "Running migrations..."
       DATABASE_URL="postgresql://nandefact_test:nandefact_test@localhost:5433/nandefact_test" \
         npx prisma migrate deploy

       echo "Running unit tests..."
       npm test

       echo "Running integration tests..."
       DATABASE_URL="postgresql://nandefact_test:nandefact_test@localhost:5433/nandefact_test" \
         npm run test:integration

       echo "Running e2e tests..."
       DATABASE_URL="postgresql://nandefact_test:nandefact_test@localhost:5433/nandefact_test" \
         REDIS_URL="redis://localhost:6380" \
         JWT_SECRET="test-jwt-secret-do-not-use-in-prod" \
         JWT_REFRESH_SECRET="test-jwt-refresh-secret-do-not-use-in-prod" \
         npm run test:e2e

       echo "Stopping test infrastructure..."
       docker compose -f docker-compose.test.yml down

       echo "All tests passed!"
       ```
       Make executable: `chmod +x scripts/test-ci.sh`

    3. **Add npm scripts to package.json:**
       - `"test:ci": "./scripts/test-ci.sh"` — Full CI pipeline
       - Ensure `test:integration` and `test:e2e` scripts exist from prior tasks

    4. **Create `.env.test` file:**
       ```
       DATABASE_URL=postgresql://nandefact_test:nandefact_test@localhost:5433/nandefact_test
       REDIS_URL=redis://localhost:6380
       JWT_SECRET=test-jwt-secret-do-not-use-in-prod
       JWT_REFRESH_SECRET=test-jwt-refresh-secret-do-not-use-in-prod
       CCFE_ENCRYPTION_KEY=test-encryption-key-32-chars-long!
       NODE_ENV=test
       ```
  </action>
  <verify>
    - `docker compose -f docker-compose.test.yml config` validates test compose file
    - `docker compose -f docker-compose.test.yml up -d --wait` starts test services
    - `bash scripts/test-ci.sh` runs full test pipeline (unit + integration + e2e)
    - `docker compose -f docker-compose.test.yml down` cleans up
    - No port conflicts with dev environment (5433 vs 5432, 6380 vs 6379)
  </verify>
  <done>
    Docker Compose test config provides isolated test PostgreSQL (tmpfs, port 5433) and Redis (port 6380). CI script runs all test suites in order. Can be used in CI pipeline.
  </done>
</task>

</tasks>

<verification>
1. `npm test` — 359 unit tests pass
2. `npm run test:integration` — integration tests pass (from 08-03)
3. `npm run test:e2e` — e2e flow test passes
4. `docker compose -f docker-compose.test.yml up -d && bash scripts/test-ci.sh` — full pipeline succeeds
5. E2E test verifies: login -> create factura -> retrieve -> list -> verify totals
</verification>

<success_criteria>
- E2E test exercises core flow: auth -> factura creation -> retrieval with correct data
- Test server uses real PostgreSQL, real Express, real adapters — only SIFEN mocked
- docker-compose.test.yml provides isolated, ephemeral test infrastructure (tmpfs)
- CI script (`test-ci.sh`) runs all test tiers (unit, integration, e2e) successfully
- No conflicts between test and dev environments (different ports, containers)
</success_criteria>

<output>
After completion, create `.planning/phases/08-infrastructure-testing/08-04-SUMMARY.md`
</output>
