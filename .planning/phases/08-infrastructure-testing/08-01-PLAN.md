---
phase: 08-infrastructure-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - nandefact-api/package.json
  - nandefact-api/prisma/schema.prisma
  - nandefact-api/Dockerfile
  - nandefact-api/docker-compose.yml
  - nandefact-api/.env.example
  - nandefact-api/src/infrastructure/persistence/prismaClient.ts
autonomous: true

must_haves:
  truths:
    - "Prisma schema defines all 6 tables matching CLAUDE.md DB model (comercio, usuario, producto, cliente, factura, factura_detalle)"
    - "docker-compose up starts PostgreSQL 16 + Redis 7 + API container with health checks"
    - "npx prisma migrate dev creates all tables in PostgreSQL"
    - "Prisma Client is generated and importable from infrastructure layer"
  artifacts:
    - path: "nandefact-api/prisma/schema.prisma"
      provides: "Database schema with all tables, relations, enums"
      contains: "model Factura"
    - path: "nandefact-api/Dockerfile"
      provides: "Multi-stage Docker build for API"
      contains: "FROM node"
    - path: "nandefact-api/docker-compose.yml"
      provides: "Full stack with postgres, redis, and api services"
      contains: "nandefact-api"
    - path: "nandefact-api/src/infrastructure/persistence/prismaClient.ts"
      provides: "Singleton Prisma client export"
      contains: "PrismaClient"
  key_links:
    - from: "nandefact-api/prisma/schema.prisma"
      to: "nandefact-api/docker-compose.yml"
      via: "DATABASE_URL environment variable"
      pattern: "DATABASE_URL"
    - from: "nandefact-api/Dockerfile"
      to: "nandefact-api/docker-compose.yml"
      via: "build context in api service"
      pattern: "build.*\\."
---

<objective>
Set up Prisma ORM with PostgreSQL schema, create Dockerfile for API, and update docker-compose.yml to include the API service. This establishes the database foundation all repository adapters will use.

Purpose: Without a real database schema and container setup, repository adapters cannot be implemented or tested.
Output: Prisma schema with migrations, Dockerfile, updated docker-compose.yml, singleton Prisma client.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key references for DB schema:
@nandefact-api/docker-compose.yml
@nandefact-api/package.json
@nandefact-api/tsconfig.json
@nandefact-api/src/domain/shared/types.ts
@nandefact-api/src/domain/factura/Factura.ts
@nandefact-api/src/domain/comercio/Comercio.ts
@nandefact-api/src/domain/cliente/Cliente.ts
@nandefact-api/src/domain/producto/Producto.ts
@nandefact-api/src/domain/usuario/Usuario.ts
@nandefact-api/src/domain/factura/ItemFactura.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Prisma + create schema matching CLAUDE.md DB model</name>
  <files>
    nandefact-api/package.json
    nandefact-api/prisma/schema.prisma
    nandefact-api/src/infrastructure/persistence/prismaClient.ts
    nandefact-api/.env.example
  </files>
  <action>
    1. Install dependencies:
       - `npm install @prisma/client`
       - `npm install -D prisma`

    2. Initialize Prisma: `npx prisma init` (will create prisma/ directory and .env)

    3. Create `prisma/schema.prisma` with the following tables matching CLAUDE.md DB model and domain entities:

       **Enums:**
       - `RolUsuario`: dueno, empleado (map "dueño" and "empleado" — use dueno without tilde for Postgres compatibility, map via adapter)
       - `TipoDocumentoIdentidad`: RUC, CI, pasaporte, innominado
       - `TasaIVA`: IVA_10, IVA_5, EXENTA (map to 10/5/0 in adapter)
       - `EstadoSifen`: pendiente, enviado, aprobado, rechazado, contingencia, cancelado
       - `CondicionPago`: contado, credito
       - `TipoDocumento`: FE (1), NC (5), ND (6), NR (7) — use integer in schema since Prisma enums can't be numeric

       **Tables (models):**

       a) `Comercio` — id (UUID, @id @default(uuid())), ruc (String @unique, up to 20 chars), razonSocial, nombreFantasia, establecimiento (String 3 chars), puntoExpedicion (String 3 chars), timbradoNumero (String), timbradoFechaInicio (DateTime), timbradoFechaFin (DateTime), tipoContribuyente (Int — 1 or 2), activo (Boolean @default(true)), direccion (String?), numeroCasa (String?), departamento (Int?), departamentoDesc (String?), distrito (Int?), distritoDesc (String?), ciudad (Int?), ciudadDesc (String?), telefono (String?), email (String?), rubro (String?), actividadEconomicaCodigo (String?), actividadEconomicaDesc (String?), tipoRegimen (Int?), cscId (String?), ccfeCertificado (Bytes?), ccfeClave (Bytes?), csc (String?), createdAt (DateTime @default(now())), updatedAt (DateTime @updatedAt). Relations: usuarios, productos, clientes, facturas.

       b) `Usuario` — id (UUID), comercioId (UUID FK), nombre, telefono (String @unique), pinHash, rol (RolUsuario enum), activo (Boolean @default(true)), intentosFallidos (Int @default(0)), bloqueadoHasta (DateTime?), createdAt. Relation: comercio.

       c) `Producto` — id (UUID), comercioId (UUID FK), nombre, codigo (String?), precioUnitario (BigInt — PYG entero), unidadMedida, tasaIVA (Int — 10/5/0), categoria (String?), activo (Boolean @default(true)), createdAt, updatedAt. Relation: comercio.

       d) `Cliente` — id (UUID), comercioId (UUID FK), nombre, rucCi (String), tipoDocumento (TipoDocumentoIdentidad enum), telefono (String?), email (String?), direccion (String?), frecuente (Boolean @default(false)), enviarWhatsApp (Boolean @default(true)), createdAt. Relation: comercio.

       e) `Factura` — id (UUID), comercioId (UUID FK), clienteId (UUID FK), cdc (String? @unique, 44 chars), numero (BigInt), tipoDocumento (Int — 1/5/6/7), establecimiento (String 3), puntoExpedicion (String 3), tipoEmision (Int — 1/2), condicionPago (CondicionPago enum), fechaEmision (DateTime), totalBruto (BigInt), totalIVA10 (BigInt), totalIVA5 (BigInt), totalExenta (BigInt), totalIVA (BigInt), estadoSifen (EstadoSifen enum @default(pendiente)), timbradoNumero (String), timbradoFechaInicio (DateTime), timbradoFechaFin (DateTime), sifenRespuesta (String?), sifenCodigoRespuesta (String?), sifenFechaEnvio (DateTime?), sifenFechaAprobacion (DateTime?), whatsappEnviado (Boolean @default(false)), whatsappFecha (DateTime?), kudePdfPath (String?), syncId (String?), createdOffline (Boolean @default(false)), syncedAt (DateTime?), facturaReferenciaId (String? — FK self-ref for NC), createdAt, updatedAt. Relations: comercio, cliente, detalles, facturaReferencia.

       f) `FacturaDetalle` — id (UUID), facturaId (UUID FK), productoId (String? — not FK for snapshot decoupling), descripcion (String), cantidad (BigInt), precioUnitario (BigInt), subtotal (BigInt), ivaTipo (Int — 1/2/3 per SIFEN), ivaTasa (Int — 10/5/0), ivaProporcion (Int @default(100)), ivaBase (BigInt), ivaMonto (BigInt). Relation: factura.

       **Important schema decisions:**
       - Use BigInt for all monetary fields (PYG sin decimales)
       - UUID as @id with @default(uuid())
       - datasource db provider = "postgresql"
       - generator client provider = "prisma-client-js"
       - Map table names to snake_case with @@map: Comercio -> "comercio", etc.
       - Map field names to snake_case with @map: razonSocial -> "razon_social", etc.

    4. Create `src/infrastructure/persistence/prismaClient.ts`:
       - Export a singleton PrismaClient instance
       - Handle connection in development vs production
       - Pattern: `const prisma = globalThis.__prisma || new PrismaClient(); if (process.env.NODE_ENV !== 'production') globalThis.__prisma = prisma; export { prisma };`
       - Declare globalThis type properly for TypeScript

    5. Create `.env.example` with all required environment variables (copy from CLAUDE.md, no real secrets).

    6. Update `.env` (or create if not exists) with DATABASE_URL pointing to docker postgres:
       `DATABASE_URL=postgresql://nandefact:nandefact_dev@localhost:5432/nandefact`
  </action>
  <verify>
    - `npx prisma validate` passes without errors
    - `npx prisma generate` generates client successfully
    - `tsc --noEmit` passes (prismaClient.ts compiles)
    - `npm test` still passes (existing 359 tests unaffected)
  </verify>
  <done>
    Prisma schema defines all 6 tables with correct types, relations, and enums. Prisma client is generated and importable. Existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Dockerfile + update docker-compose.yml with API service</name>
  <files>
    nandefact-api/Dockerfile
    nandefact-api/docker-compose.yml
    nandefact-api/.dockerignore
  </files>
  <action>
    1. Create `Dockerfile` with multi-stage build:

       ```dockerfile
       # Stage 1: Build
       FROM node:20-alpine AS builder
       WORKDIR /app
       COPY package*.json ./
       COPY prisma ./prisma/
       RUN npm ci
       RUN npx prisma generate
       COPY tsconfig.json ./
       COPY src ./src/
       RUN npm run build

       # Stage 2: Production
       FROM node:20-alpine
       WORKDIR /app
       COPY package*.json ./
       COPY prisma ./prisma/
       RUN npm ci --omit=dev
       RUN npx prisma generate
       COPY --from=builder /app/dist ./dist/
       EXPOSE 3000
       # Run migrations then start
       CMD ["sh", "-c", "npx prisma migrate deploy && node dist/index.js"]
       ```

    2. Create `.dockerignore`:
       ```
       node_modules
       dist
       .env
       .git
       tests
       *.md
       ```

    3. Update `docker-compose.yml` to add `api` service:
       - Build from current directory (`.`)
       - Depends on postgres and redis (with `condition: service_healthy`)
       - Environment variables: DATABASE_URL, REDIS_URL, JWT_SECRET (dev value), JWT_REFRESH_SECRET (dev value), NODE_ENV=development, PORT=3000
       - Port mapping 3000:3000
       - Volumes: mount prisma/ for development migrations
       - Health check: curl http://localhost:3000/health (install curl in Dockerfile)
       - Also add a `migrate` service (one-shot) that runs `npx prisma migrate deploy` against the DB for CI use

    4. Keep existing postgres and redis services unchanged except ensure they have proper networking.
  </action>
  <verify>
    - `docker compose config` validates the compose file without errors
    - `docker compose build api` builds the API image successfully (may take a few minutes)
    - Dockerfile syntax is valid
  </verify>
  <done>
    Docker Compose file defines 3 services (postgres, redis, api) with health checks and proper dependency ordering. Dockerfile builds API with multi-stage pattern. docker compose build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` — schema is valid
2. `npx prisma generate` — client generates without error
3. `docker compose config` — compose file is valid YAML
4. `npm test` — all 359 existing tests still pass
5. `tsc --noEmit` — TypeScript compilation succeeds
</verification>

<success_criteria>
- Prisma schema has 6 models (Comercio, Usuario, Producto, Cliente, Factura, FacturaDetalle) with correct types and relations
- PrismaClient singleton is exported from infrastructure/persistence/prismaClient.ts
- Dockerfile builds successfully with multi-stage pattern
- docker-compose.yml has postgres + redis + api services with health checks
- All existing 359 unit tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-infrastructure-testing/08-01-SUMMARY.md`
</output>
