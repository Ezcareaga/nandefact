---
phase: 08-infrastructure-testing
plan: 03
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - nandefact-api/tests/integration/helpers/testDb.ts
  - nandefact-api/tests/integration/persistence/ComercioRepositoryPg.test.ts
  - nandefact-api/tests/integration/persistence/UsuarioRepositoryPg.test.ts
  - nandefact-api/tests/integration/persistence/ProductoRepositoryPg.test.ts
  - nandefact-api/tests/integration/persistence/ClienteRepositoryPg.test.ts
  - nandefact-api/tests/integration/persistence/FacturaRepositoryPg.test.ts
  - nandefact-api/tests/integration/auth/AuthServiceJWT.test.ts
  - nandefact-api/tests/integration/auth/HashServiceBcrypt.test.ts
  - nandefact-api/vitest.config.ts
  - nandefact-api/package.json
autonomous: true

must_haves:
  truths:
    - "Repository integration tests run against a real PostgreSQL database (not mocked)"
    - "Each repository test suite cleans up database state via DELETE between tests"
    - "All repository CRUD operations verified: save, findById, findByComercio, etc."
    - "Factura repository correctly persists and reconstructs items, CDC, estado, and value objects"
    - "Auth tests (AuthServiceJWT, HashServiceBcrypt) run without PostgreSQL — they are pure unit-style tests placed in integration/ for organizational consistency"
    - "Tests can be run with npm run test:integration and are separate from unit tests"
  artifacts:
    - path: "nandefact-api/tests/integration/helpers/testDb.ts"
      provides: "Test database setup, teardown, and PrismaClient for tests"
      exports: ["getTestPrisma", "cleanDatabase"]
    - path: "nandefact-api/tests/integration/persistence/FacturaRepositoryPg.test.ts"
      provides: "Integration tests for the most complex repository"
      contains: "FacturaRepositoryPg"
    - path: "nandefact-api/tests/integration/auth/AuthServiceJWT.test.ts"
      provides: "JWT token generation and verification tests"
      contains: "AuthServiceJWT"
  key_links:
    - from: "nandefact-api/tests/integration/helpers/testDb.ts"
      to: "nandefact-api/prisma/schema.prisma"
      via: "PrismaClient uses DATABASE_URL to connect"
      pattern: "PrismaClient"
    - from: "nandefact-api/tests/integration/persistence/FacturaRepositoryPg.test.ts"
      to: "nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts"
      via: "imports and tests the adapter"
      pattern: "FacturaRepositoryPg"
---

<objective>
Write integration tests that run all repository adapters and auth services against a real PostgreSQL database, verifying correct CRUD operations, entity mapping, and data integrity.

Purpose: Prove the persistence layer works correctly with real database operations, not just in-memory mocks.
Output: Integration test suite with ~40-60 tests covering all 5 repositories + 2 auth services.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-infrastructure-testing/08-01-SUMMARY.md
@.planning/phases/08-infrastructure-testing/08-02-SUMMARY.md

Source adapters to test:
@nandefact-api/src/infrastructure/persistence/ComercioRepositoryPg.ts
@nandefact-api/src/infrastructure/persistence/UsuarioRepositoryPg.ts
@nandefact-api/src/infrastructure/persistence/ProductoRepositoryPg.ts
@nandefact-api/src/infrastructure/persistence/ClienteRepositoryPg.ts
@nandefact-api/src/infrastructure/persistence/FacturaRepositoryPg.ts
@nandefact-api/src/infrastructure/auth/AuthServiceJWT.ts
@nandefact-api/src/infrastructure/auth/HashServiceBcrypt.ts

Domain entities for test data construction:
@nandefact-api/src/domain/comercio/Comercio.ts
@nandefact-api/src/domain/usuario/Usuario.ts
@nandefact-api/src/domain/producto/Producto.ts
@nandefact-api/src/domain/cliente/Cliente.ts
@nandefact-api/src/domain/factura/Factura.ts
@nandefact-api/src/domain/factura/ItemFactura.ts
@nandefact-api/src/domain/shared/types.ts

Test configuration:
@nandefact-api/vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test infrastructure + vitest config + repository integration tests (Comercio, Usuario, Producto, Cliente)</name>
  <files>
    nandefact-api/tests/integration/helpers/testDb.ts
    nandefact-api/tests/integration/persistence/ComercioRepositoryPg.test.ts
    nandefact-api/tests/integration/persistence/UsuarioRepositoryPg.test.ts
    nandefact-api/tests/integration/persistence/ProductoRepositoryPg.test.ts
    nandefact-api/tests/integration/persistence/ClienteRepositoryPg.test.ts
    nandefact-api/vitest.config.ts
    nandefact-api/package.json
  </files>
  <action>
    1. **Update vitest.config.ts** to support separate test workspaces:
       - Keep existing config for unit tests (tests/unit/**/*.test.ts)
       - Add a new script `test:integration` in package.json: `vitest run --config vitest.integration.config.ts`
       - Create `vitest.integration.config.ts` that includes only `tests/integration/**/*.test.ts`
       - Set a longer timeout (30s) for integration tests
       - Alternatively, use vitest projects feature or simply add a new npm script that runs vitest with a different include pattern. The simplest approach: add `"test:integration": "vitest run tests/integration/"` to package.json scripts. Vitest will use the existing config but only run files matching the path argument.

    2. **Create `tests/integration/helpers/testDb.ts`:**
       - Import PrismaClient from @prisma/client
       - Export `getTestPrisma()`: Creates a PrismaClient connecting to `DATABASE_URL` (test DB). Reuse singleton across tests.
       - Export `cleanDatabase(prisma)`: Deletes all data in correct order (respecting FK constraints): factura_detalle → factura → cliente → producto → usuario → comercio. Use `prisma.$executeRawUnsafe('DELETE FROM ...')` or `prisma.facturaDetalle.deleteMany()` in order.
       - Export `disconnectTestDb(prisma)`: Calls `prisma.$disconnect()`.
       - Document: Tests require PostgreSQL running (via docker-compose up postgres).

    3. **Create helper factory functions** in testDb.ts or a separate `testFactories.ts`:
       - `crearComercioTest(overrides?)`: Returns a valid Comercio domain entity with realistic test data (RUC "80069563-1", razón social "Almacén Doña María", timbrado vigente, etc.)
       - `crearUsuarioTest(comercioId, overrides?)`: Returns a valid Usuario with PIN hash
       - `crearProductoTest(comercioId, overrides?)`: Returns valid Producto (mandioca, Gs 5000/kg)
       - `crearClienteTest(comercioId, overrides?)`: Returns valid Cliente

    4. **ComercioRepositoryPg.test.ts** (~8-10 tests):
       - beforeAll: getTestPrisma(), run migrations if needed
       - beforeEach: cleanDatabase()
       - afterAll: disconnectTestDb()
       - Tests:
         - `save() creates a new comercio` — save, then findById, verify all fields
         - `save() updates existing comercio` — save twice with same id, different data
         - `findById() returns null for non-existent id`
         - `findByRuc() finds by RUC string`
         - `findByRuc() returns null for non-existent RUC`
         - `save() correctly maps RUC value object` — verify ruc field stored as string, reconstructed as RUC
         - `save() correctly maps Timbrado value object` — verify timbrado fields stored/reconstructed
         - `save() persists optional SIFEN fields` — direccion, telefono, etc.

    5. **UsuarioRepositoryPg.test.ts** (~6-8 tests):
       - Requires comercio to exist first (FK)
       - Tests:
         - `save() creates a new usuario`
         - `save() updates existing usuario`
         - `findById() returns null for non-existent id`
         - `findByTelefono() finds by phone number`
         - `findByTelefono() returns null for non-existent phone`
         - `save() correctly maps rol dueño <-> dueno enum`
         - `save() correctly maps bloqueadoHasta Date`
         - `save() correctly maps intentosFallidos`

    6. **ProductoRepositoryPg.test.ts** (~8-10 tests):
       - Requires comercio (FK)
       - Tests:
         - `save() creates producto with BigInt precioUnitario`
         - `save() updates existing producto`
         - `findById() returns producto with correct number types`
         - `findByComercio() returns paginated results`
         - `findByComercio() with page/pageSize works`
         - `findByComercio() with soloActivos=true filters inactive`
         - `findByComercio() returns total count for pagination`
         - `findById() returns null for non-existent`
         - `save() correctly maps tasaIVA (10/5/0)`

    7. **ClienteRepositoryPg.test.ts** (~8-10 tests):
       - Requires comercio (FK)
       - Tests:
         - `save() creates cliente`
         - `save() updates existing`
         - `findById() returns null for non-existent`
         - `findByComercio() returns all clientes for comercio`
         - `buscar() finds by nombre (case-insensitive)`
         - `buscar() finds by rucCi`
         - `buscar() returns empty for no matches`
         - `buscar() only returns clientes from same comercio`
         - `save() correctly maps tipoDocumento enum`
         - `save() correctly maps optional fields (telefono, email)`
  </action>
  <verify>
    - `docker compose up -d postgres` starts PostgreSQL
    - `DATABASE_URL=postgresql://nandefact:nandefact_dev@localhost:5432/nandefact npx prisma migrate dev` creates tables
    - `npm run test:integration` runs integration tests and all pass
    - `npm test` still runs only unit tests and passes (359 tests)
  </verify>
  <done>
    Test infrastructure created with database cleanup helper. 4 repository integration test suites pass against real PostgreSQL. Unit tests remain unaffected at 359 passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Factura repository integration tests + AuthServiceJWT + HashServiceBcrypt tests</name>
  <files>
    nandefact-api/tests/integration/persistence/FacturaRepositoryPg.test.ts
    nandefact-api/tests/integration/auth/AuthServiceJWT.test.ts
    nandefact-api/tests/integration/auth/HashServiceBcrypt.test.ts
  </files>
  <action>
    1. **FacturaRepositoryPg.test.ts** (~12-15 tests) — MOST COMPLEX:
       - Setup: Create comercio and cliente in beforeAll (required FKs)
       - Tests:
         - `save() creates factura with items` — verify factura + detalles persisted
         - `save() correctly maps monetary BigInt fields` — totalBruto, totalIVA10, etc.
         - `save() correctly maps CDC value object` — 44-digit string stored and reconstructed
         - `save() correctly maps NumeroFactura value object` — establecimiento, punto, numero fields
         - `save() correctly maps Timbrado to snapshot fields`
         - `save() updates existing factura` — change estado, save again
         - `save() persists multiple items with IVA calculations`
         - `findById() returns factura with items reconstructed`
         - `findById() returns null for non-existent`
         - `findById() correctly reconstructs ItemFactura with MontoIVA`
         - `findByComercio() returns facturas for comercio`
         - `findByComercio() does NOT return facturas from other comercios`
         - `findPendientes() only returns pendiente estado`
         - `findPendientes() does NOT return aprobado/rechazado facturas`
         - `save() handles factura without CDC (pendiente, pre-generation)`

       **Key test for entity reconstruction:**
       After save + findById, verify:
       - factura.items has correct length
       - Each item has correct descripcion, cantidad, precioUnitario, subtotal, tasaIVA
       - Each item.iva has correct montoIVACalculado and baseGravada
       - factura.totalBruto matches sum of item subtotals
       - factura.totalIVA10 + totalIVA5 matches expected
       - factura.estado matches saved state
       - factura.cdc?.value matches saved CDC string

    2. **AuthServiceJWT.test.ts** (~8-10 tests) — Does NOT need database:
       - Tests:
         - `generarTokens() returns accessToken, refreshToken, expiresIn`
         - `verificarAccessToken() returns correct payload`
         - `verificarAccessToken() throws on invalid token`
         - `verificarAccessToken() throws on expired token` (use short expiry for test)
         - `verificarRefreshToken() returns correct payload`
         - `verificarRefreshToken() throws on invalid token`
         - `access token cannot be verified as refresh token` (different secrets)
         - `refresh token cannot be verified as access token`
         - `payload contains usuarioId, comercioId, rol`

    3. **HashServiceBcrypt.test.ts** (~4-5 tests) — Does NOT need database:
       - Tests:
         - `hash() produces a hash different from input`
         - `verificar() returns true for correct PIN`
         - `verificar() returns false for wrong PIN`
         - `hash() produces different hashes for same input (salt)`
         - `hash() works with 4-6 digit PIN strings`
  </action>
  <verify>
    - `npm run test:integration` runs all integration tests and passes
    - Factura repository tests verify complete round-trip (save -> findById with items)
    - Auth tests verify token generation + verification
    - Hash tests verify bcrypt correctness
  </verify>
  <done>
    Factura repository integration tests verify complex entity mapping (items, CDC, value objects, BigInt). AuthServiceJWT tests verify token lifecycle. HashServiceBcrypt tests verify PIN hashing. All integration tests pass against real PostgreSQL.
  </done>
</task>

</tasks>

<verification>
1. `npm test` — all 359 unit tests still pass
2. `npm run test:integration` — all integration tests pass against real PostgreSQL
3. Integration tests clean up database state between runs (no leftover data)
4. Factura round-trip test: save factura with 3 items -> findById -> verify all fields match
5. Auth round-trip test: generarTokens -> verificarAccessToken -> payload matches
</verification>

<success_criteria>
- Test infrastructure helper provides getTestPrisma() and cleanDatabase()
- ~40-60 integration tests across 7 test files
- All integration tests pass against real PostgreSQL (docker compose up postgres)
- Factura repository tests verify items, CDC, value objects, BigInt fields round-trip
- AuthServiceJWT tests verify token generation/verification with different secrets
- HashServiceBcrypt tests verify PIN hash/verify cycle
- Unit tests (359) remain unaffected and passing
</success_criteria>

<output>
After completion, create `.planning/phases/08-infrastructure-testing/08-03-SUMMARY.md`
</output>
