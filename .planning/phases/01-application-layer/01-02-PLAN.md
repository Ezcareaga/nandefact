---
phase: 01-application-layer
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - nandefact-api/src/application/facturacion/EnviarDE.ts
  - nandefact-api/src/application/facturacion/AnularFactura.ts
  - nandefact-api/tests/unit/application/facturacion/EnviarDE.test.ts
  - nandefact-api/tests/unit/application/facturacion/AnularFactura.test.ts
autonomous: true

must_haves:
  truths:
    - "EnviarDE loads a pending factura, signs XML via IFirmaDigital, sends to SIFEN via ISifenGateway, and updates factura state to enviado/aprobado/rechazado"
    - "EnviarDE throws FacturaNoEncontradaError if factura does not exist"
    - "AnularFactura sends cancelation event for an approved factura via ISifenGateway.anularDE"
    - "AnularFactura throws FacturaNoAnulableError if factura is not in aprobado state"
  artifacts:
    - path: "nandefact-api/src/application/facturacion/EnviarDE.ts"
      provides: "EnviarDE use case class"
      exports: ["EnviarDE", "EnviarDEInput", "EnviarDEOutput"]
    - path: "nandefact-api/src/application/facturacion/AnularFactura.ts"
      provides: "AnularFactura use case class"
      exports: ["AnularFactura", "AnularFacturaInput", "AnularFacturaOutput"]
    - path: "nandefact-api/tests/unit/application/facturacion/EnviarDE.test.ts"
      provides: "Unit tests for EnviarDE"
      min_lines: 60
    - path: "nandefact-api/tests/unit/application/facturacion/AnularFactura.test.ts"
      provides: "Unit tests for AnularFactura"
      min_lines: 50
  key_links:
    - from: "nandefact-api/src/application/facturacion/EnviarDE.ts"
      to: "IFacturaRepository"
      via: "loads factura by ID, saves updated state"
      pattern: "facturaRepository\\.(findById|save)"
    - from: "nandefact-api/src/application/facturacion/EnviarDE.ts"
      to: "ISifenGateway"
      via: "sends signed XML to SIFEN"
      pattern: "sifenGateway\\.enviarDE"
    - from: "nandefact-api/src/application/facturacion/EnviarDE.ts"
      to: "IFirmaDigital"
      via: "signs XML before sending"
      pattern: "firmaDigital\\.firmar"
    - from: "nandefact-api/src/application/facturacion/AnularFactura.ts"
      to: "ISifenGateway"
      via: "sends cancelation event"
      pattern: "sifenGateway\\.anularDE"
---

<objective>
Implement EnviarDE and AnularFactura use cases — the SIFEN communication orchestration.

Purpose: EnviarDE is the use case that takes a pending factura and sends it through the SIFEN pipeline (sign XML -> send SOAP -> update state). AnularFactura handles cancelation of approved DTEs. Both interact with ISifenGateway and IFirmaDigital ports. These use cases are grouped because they share the SIFEN interaction concern.

Output: Two working use cases with TDD tests covering happy paths and error scenarios.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Domain entities and ports
@nandefact-api/src/domain/factura/Factura.ts
@nandefact-api/src/domain/factura/IFacturaRepository.ts
@nandefact-api/src/domain/factura/ISifenGateway.ts
@nandefact-api/src/domain/factura/IFirmaDigital.ts
@nandefact-api/src/domain/factura/CDC.ts
@nandefact-api/src/domain/shared/types.ts
@nandefact-api/src/domain/errors/DomainError.ts

# Application errors (created by Plan 01)
# If Plan 01 hasn't run yet, create the error files inline (ApplicationError, FacturaNoEncontradaError, FacturaNoAnulableError)
# Read Plan 01 SUMMARY if it exists: @.planning/phases/01-application-layer/01-01-SUMMARY.md

# Test conventions
@nandefact-api/tests/unit/domain/entities/Factura.test.ts
@nandefact-api/vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED+GREEN — EnviarDE use case with tests</name>
  <files>
    nandefact-api/tests/unit/application/facturacion/EnviarDE.test.ts
    nandefact-api/src/application/facturacion/EnviarDE.ts
  </files>
  <action>
    **IMPORTANT PRE-CHECK:** Before starting, check if `src/application/errors/ApplicationError.ts` and `src/application/errors/FacturaNoEncontradaError.ts` exist (created by Plan 01). If they do NOT exist yet, create them first:
    - `ApplicationError` extends Error, sets `this.name = this.constructor.name`
    - `FacturaNoEncontradaError` extends ApplicationError, takes facturaId

    **Phase RED — Write tests first** in `tests/unit/application/facturacion/EnviarDE.test.ts`:

    EnviarDE needs an XML generation step. For this phase, use a simple XML stub (the actual XML generation is Phase 2 - SIFEN Integration). The use case will accept an `IXmlGenerator` port or, simpler for MVP, generate a placeholder XML string from factura data. Decision: **Use a simple `generarXmlPlaceholder(factura)` private method** that returns a minimal XML string containing the CDC. This avoids creating a port for something that will be completely replaced in Phase 2.

    **Test setup:**
    - Create a Factura in 'pendiente' state WITH items and CDC already generated (simulating a factura created by CrearFactura)
    - To do this: create Factura, add items, call generarCDC, then mock findById to return this factura
    - Mock IFacturaRepository: { save: vi.fn(), findById: vi.fn(), findByComercio: vi.fn(), findPendientes: vi.fn() }
    - Mock IFirmaDigital: { firmar: vi.fn().mockResolvedValue('<xml-firmado/>') }
    - Mock ISifenGateway: { enviarDE: vi.fn(), consultarEstado: vi.fn(), anularDE: vi.fn() }

    **EnviarDEInput:** `{ facturaId: string }`
    **EnviarDEOutput:** `{ cdc: string, estadoSifen: EstadoSifen, codigoRespuesta: string, mensajeRespuesta: string }`

    **Test cases:**
    1. `debería firmar XML, enviar a SIFEN, y marcar aprobada cuando código es 0260` — Mock enviarDE returns { codigo: '0260', mensaje: 'Aprobado', cdc: '...' }. Assert: firmar called, enviarDE called with signed XML, save called, output.estadoSifen = 'aprobado'.

    2. `debería marcar aprobada cuando código es 0261 (aprobado con observación)` — Mock enviarDE returns { codigo: '0261', ... }. Assert: output.estadoSifen = 'aprobado'.

    3. `debería marcar rechazada cuando código es 0300+` — Mock enviarDE returns { codigo: '0300', mensaje: 'Error validación' }. Assert: output.estadoSifen = 'rechazado', save called.

    4. `debería lanzar FacturaNoEncontradaError si factura no existe` — findById returns null. Assert: throws FacturaNoEncontradaError.

    5. `debería llamar firmaDigital.firmar con XML generado` — Assert firmar was called with a string containing the CDC value.

    **Phase GREEN — Implement** `src/application/facturacion/EnviarDE.ts`:

    **EnviarDE class:**
    - Constructor: `{ facturaRepository: IFacturaRepository, firmaDigital: IFirmaDigital, sifenGateway: ISifenGateway }`
    - `async execute(input: EnviarDEInput): Promise<EnviarDEOutput>`

    **execute() flow:**
    1. Load factura: `findById(input.facturaId)` — if null, throw FacturaNoEncontradaError
    2. Generate placeholder XML: `<DE><CDC>${factura.cdc!.value}</CDC></DE>` (minimal, will be replaced in Phase 2)
    3. Sign XML: `await this.firmaDigital.firmar(xmlPlaceholder)`
    4. Send to SIFEN: `await this.sifenGateway.enviarDE(xmlFirmado)`
    5. Update factura state based on SIFEN response code:
       - `0260` or `0261` → `factura.marcarAprobada()`
       - Anything else → `factura.marcarRechazada()`
    6. Also call `factura.marcarEnviada()` BEFORE sending (to mark the attempt). Wait — checking the domain: marcarEnviada sets estado='enviado', and then marcarAprobada/marcarRechazada would need to work from 'enviado' state. Looking at Factura.ts: marcarAprobada() just sets `_estado = 'aprobado'` with no guard. marcarRechazada() same. marcarEnviada() checks validarMutable(). So the flow is: marcarEnviada() first (marks intent), then after response: marcarAprobada() or marcarRechazada().
    7. Save factura with updated state
    8. Return EnviarDEOutput

    Use relative imports with `.js` extensions. Compile-check with tsc.
  </action>
  <verify>Run `cd nandefact-api && npx vitest run tests/unit/application/facturacion/EnviarDE.test.ts` — ALL 5 tests pass. Run `npx tsc --noEmit` — compiles.</verify>
  <done>EnviarDE use case implemented with 5 passing tests. Signs XML, sends to SIFEN, updates factura state (aprobado for 0260/0261, rechazado for others). Handles not-found error.</done>
</task>

<task type="auto">
  <name>Task 2: RED+GREEN — AnularFactura use case with tests</name>
  <files>
    nandefact-api/tests/unit/application/facturacion/AnularFactura.test.ts
    nandefact-api/src/application/facturacion/AnularFactura.ts
  </files>
  <action>
    **IMPORTANT PRE-CHECK:** Check if `src/application/errors/FacturaNoAnulableError.ts` exists (from Plan 01). If not, create it:
    - Extends ApplicationError
    - Constructor: `(facturaId: string, estado: string)` → message: `Factura ${facturaId} no se puede anular en estado ${estado}`

    **Phase RED — Write tests first** in `tests/unit/application/facturacion/AnularFactura.test.ts`:

    **Test setup:**
    - Create a Factura in 'aprobado' state (create, add items, generarCDC, marcarEnviada, marcarAprobada)
    - Mock IFacturaRepository, ISifenGateway

    **AnularFacturaInput:** `{ facturaId: string, motivo: string }`
    **AnularFacturaOutput:** `{ cdc: string, codigoRespuesta: string, mensajeRespuesta: string, anulada: boolean }`

    **Test cases:**
    1. `debería enviar evento cancelación a SIFEN para factura aprobada` — Mock anularDE returns { codigo: '0260', mensaje: 'Cancelado', cdc: '...' }. Assert: anularDE called with (cdc, motivo), output.anulada = true.

    2. `debería lanzar FacturaNoAnulableError si factura está en estado pendiente` — Factura in 'pendiente' state. Assert: throws FacturaNoAnulableError.

    3. `debería lanzar FacturaNoAnulableError si factura está en estado rechazado` — Factura in 'rechazado' state. Assert: throws FacturaNoAnulableError.

    4. `debería lanzar FacturaNoEncontradaError si factura no existe` — findById returns null. Assert: throws FacturaNoEncontradaError.

    5. `debería retornar anulada=false si SIFEN rechaza la cancelación` — Mock anularDE returns { codigo: '0300', mensaje: 'Rechazo' }. Assert: output.anulada = false.

    **Phase GREEN — Implement** `src/application/facturacion/AnularFactura.ts`:

    **AnularFactura class:**
    - Constructor: `{ facturaRepository: IFacturaRepository, sifenGateway: ISifenGateway }`
    - `async execute(input: AnularFacturaInput): Promise<AnularFacturaOutput>`

    **execute() flow:**
    1. Load factura: `findById(input.facturaId)` — if null, throw FacturaNoEncontradaError
    2. Validate factura estado === 'aprobado' — if not, throw FacturaNoAnulableError(facturaId, factura.estado)
    3. Get CDC: `factura.cdc!.value` (aprobada factura always has CDC)
    4. Call `await this.sifenGateway.anularDE(cdc, input.motivo)`
    5. Determine if cancelation succeeded: codigo 0260 or 0261 → anulada = true, else false
    6. Return AnularFacturaOutput (do NOT change factura state here — cancelation is a SIFEN event, the state model might need a 'cancelado' state which doesn't exist yet. For now, just report the result.)

    Use relative imports with `.js` extensions.
  </action>
  <verify>Run `cd nandefact-api && npx vitest run tests/unit/application/facturacion/AnularFactura.test.ts` — ALL 5 tests pass. Run `npx tsc --noEmit` — compiles. Run `npx vitest run` — all tests pass (no regressions).</verify>
  <done>AnularFactura use case implemented with 5 passing tests. Validates factura must be in aprobado state. Sends cancelation event to SIFEN. Reports success/failure. No state mutation on factura (deferred to when we have proper 'cancelado' state).</done>
</task>

</tasks>

<verification>
1. `cd nandefact-api && npx tsc --noEmit` — zero TypeScript errors
2. `cd nandefact-api && npx vitest run` — all tests passing (59 domain + Plan 01 tests + 10 new from this plan)
3. EnviarDE use case exists at `src/application/facturacion/EnviarDE.ts`
4. AnularFactura use case exists at `src/application/facturacion/AnularFactura.ts`
5. Both use cases use constructor injection for port dependencies
6. Both use cases have input/output DTOs (not domain entities crossing boundary)
</verification>

<success_criteria>
- EnviarDE orchestrates: load factura → generate XML → sign → send SIFEN → update state → save
- AnularFactura orchestrates: load factura → validate aprobado → send cancelation → report result
- 10 new tests pass (5 EnviarDE + 5 AnularFactura)
- No regressions in existing tests
- TypeScript strict mode compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-application-layer/01-02-SUMMARY.md`
</output>
