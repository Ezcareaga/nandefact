---
phase: 01-application-layer
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - nandefact-api/src/application/errors/ApplicationError.ts
  - nandefact-api/src/application/errors/FacturaNoEncontradaError.ts
  - nandefact-api/src/application/errors/ComercioNoEncontradoError.ts
  - nandefact-api/src/application/errors/FacturaNoAnulableError.ts
  - nandefact-api/src/domain/comercio/IComercioRepository.ts
  - nandefact-api/src/application/facturacion/CrearFactura.ts
  - nandefact-api/tests/unit/application/facturacion/CrearFactura.test.ts
autonomous: true

must_haves:
  truths:
    - "CrearFactura use case accepts input DTO, creates Factura with items, generates CDC, and saves via IFacturaRepository"
    - "CrearFactura validates that comercio exists and is active before creating factura"
    - "CrearFactura returns output DTO with facturaId, CDC value, totals, and estado=pendiente"
    - "Application errors distinguish from domain errors (ApplicationError base class)"
  artifacts:
    - path: "nandefact-api/src/application/facturacion/CrearFactura.ts"
      provides: "CrearFactura use case class with execute() method"
      exports: ["CrearFactura", "CrearFacturaInput", "CrearFacturaOutput"]
    - path: "nandefact-api/src/application/errors/ApplicationError.ts"
      provides: "Base application error"
      exports: ["ApplicationError"]
    - path: "nandefact-api/src/domain/comercio/IComercioRepository.ts"
      provides: "Comercio repository port interface"
      exports: ["IComercioRepository"]
    - path: "nandefact-api/tests/unit/application/facturacion/CrearFactura.test.ts"
      provides: "Unit tests for CrearFactura use case"
      min_lines: 80
  key_links:
    - from: "nandefact-api/src/application/facturacion/CrearFactura.ts"
      to: "IFacturaRepository"
      via: "constructor injection, calls save()"
      pattern: "facturaRepository\\.save"
    - from: "nandefact-api/src/application/facturacion/CrearFactura.ts"
      to: "IComercioRepository"
      via: "constructor injection, calls findById()"
      pattern: "comercioRepository\\.findById"
    - from: "nandefact-api/src/application/facturacion/CrearFactura.ts"
      to: "Factura domain entity"
      via: "creates Factura, calls agregarItem, generarCDC"
      pattern: "factura\\.agregarItem|factura\\.generarCDC"
---

<objective>
Implement the CrearFactura use case with application-layer errors and the IComercioRepository port.

Purpose: CrearFactura is the core use case that creates a factura electrónica with CDC, calculates IVA, and persists it. This is the first use case that exercises the full domain model (Factura, ItemFactura, CDC, MontoIVA) through application-layer orchestration.

Output: Working CrearFactura use case with TDD tests, application error classes, and IComercioRepository port interface.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Domain entities and ports (already built, 59 tests passing)
@nandefact-api/src/domain/factura/Factura.ts
@nandefact-api/src/domain/factura/ItemFactura.ts
@nandefact-api/src/domain/factura/CDC.ts
@nandefact-api/src/domain/factura/MontoIVA.ts
@nandefact-api/src/domain/factura/NumeroFactura.ts
@nandefact-api/src/domain/factura/IFacturaRepository.ts
@nandefact-api/src/domain/factura/ISifenGateway.ts
@nandefact-api/src/domain/factura/IFirmaDigital.ts
@nandefact-api/src/domain/comercio/Comercio.ts
@nandefact-api/src/domain/comercio/RUC.ts
@nandefact-api/src/domain/comercio/Timbrado.ts
@nandefact-api/src/domain/cliente/Cliente.ts
@nandefact-api/src/domain/shared/types.ts
@nandefact-api/src/domain/errors/DomainError.ts

# Existing test pattern
@nandefact-api/tests/unit/domain/entities/Factura.test.ts
@nandefact-api/vitest.config.ts
@nandefact-api/tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create application errors and IComercioRepository port</name>
  <files>
    nandefact-api/src/application/errors/ApplicationError.ts
    nandefact-api/src/application/errors/FacturaNoEncontradaError.ts
    nandefact-api/src/application/errors/ComercioNoEncontradoError.ts
    nandefact-api/src/application/errors/FacturaNoAnulableError.ts
    nandefact-api/src/domain/comercio/IComercioRepository.ts
  </files>
  <action>
    1. Create `src/application/errors/ApplicationError.ts`:
       - Extends `Error`, sets `this.name = this.constructor.name`
       - Separate from DomainError — application layer has its own error hierarchy
       - ESM import: use `.js` extensions

    2. Create `src/application/errors/FacturaNoEncontradaError.ts`:
       - Extends ApplicationError
       - Constructor takes `facturaId: string`, message: `Factura no encontrada: ${facturaId}`

    3. Create `src/application/errors/ComercioNoEncontradoError.ts`:
       - Extends ApplicationError
       - Constructor takes `comercioId: string`, message: `Comercio no encontrado: ${comercioId}`

    4. Create `src/application/errors/FacturaNoAnulableError.ts`:
       - Extends ApplicationError
       - Constructor takes `facturaId: string, estado: string`, message: `Factura ${facturaId} no se puede anular en estado ${estado}`
       - This will be used by AnularFactura in Plan 02 but created here for completeness

    5. Create `src/domain/comercio/IComercioRepository.ts`:
       - Port interface with: `findById(id: string): Promise<Comercio | null>`
       - Import Comercio type. Use `.js` extension for ESM.
       - This is a domain port (goes in domain/, not application/) following hexagonal architecture — same pattern as IFacturaRepository.

    All files must use ESM (`export`, not `export default`; `.js` extensions in relative imports).
    All files must compile with strict TypeScript settings (noUncheckedIndexedAccess, exactOptionalPropertyTypes, noImplicitReturns).
    Remove the `.gitkeep` files from `src/application/facturacion/`, `src/application/auth/`, `src/application/sync/` since real files will now exist.
  </action>
  <verify>Run `cd nandefact-api && npx tsc --noEmit` — must compile with zero errors. Run `npx vitest run` — existing 59 tests must still pass.</verify>
  <done>ApplicationError base class and 3 specific errors exist. IComercioRepository port interface exists in domain layer. TypeScript compiles. No regressions in existing tests.</done>
</task>

<task type="auto">
  <name>Task 2: RED — Write failing tests for CrearFactura use case</name>
  <files>
    nandefact-api/tests/unit/application/facturacion/CrearFactura.test.ts
  </files>
  <action>
    Create test file `tests/unit/application/facturacion/CrearFactura.test.ts` with the following test cases. Use Vitest `vi.fn()` for mocking ports. Follow existing test conventions (import from relative paths with `.js` extension, `describe`/`it` blocks, Spanish test descriptions).

    **Test setup (shared across tests):**
    - Create mock IFacturaRepository: `{ save: vi.fn().mockResolvedValue(undefined), findById: vi.fn(), findByComercio: vi.fn(), findPendientes: vi.fn() }`
    - Create mock IComercioRepository: `{ findById: vi.fn() }`
    - Create a valid Comercio instance using the existing Comercio entity: `new Comercio({ id: 'comercio-uuid', ruc: new RUC('80069563-1'), razonSocial: 'Doña María Almacén', nombreFantasia: 'Almacén María', timbrado: new Timbrado('12558946', new Date('2024-01-01'), new Date('2025-12-31')), establecimiento: '001', puntoExpedicion: '003', tipoContribuyente: 1 })`
    - Mock comercioRepository.findById to return this Comercio

    **Define CrearFacturaInput type (in test, expected from the use case module):**
    ```typescript
    {
      comercioId: string;
      clienteId: string;
      tipoDocumento: TipoDocumento; // default 1 for FE
      condicionPago: CondicionPago;
      fechaEmision: Date;
      items: Array<{
        descripcion: string;
        cantidad: number;
        precioUnitario: number;
        tasaIVA: TasaIVA;
      }>;
    }
    ```

    **Test cases:**
    1. `debería crear factura con items, calcular IVA, generar CDC, y guardar` — happy path. Input: 2 items (mandioca 3×5000 IVA 10%, arroz 2×8000 IVA 5%). Assert: save called once, output has facturaId (non-empty string), cdc (44 chars), estado='pendiente', totalBruto=31000, totalIVA10=1364, totalIVA5=762.

    2. `debería lanzar ComercioNoEncontradoError si comercio no existe` — mock findById returns null. Assert: throws ComercioNoEncontradoError.

    3. `debería generar UUID como facturaId` — Assert output.facturaId is non-empty string (not validating UUID format, just that it's truthy).

    4. `debería usar timbrado del comercio para la factura` — Assert save was called and the factura passed to save has the comercio's timbrado.

    5. `debería usar establecimiento y puntoExpedicion del comercio para NumeroFactura` — Assert save called with factura whose numeroFactura has the correct establecimiento and punto from the Comercio.

    6. `debería lanzar FacturaSinItemsError si items array vacío` — Input with empty items array. Assert: throws FacturaSinItemsError (domain error, bubbled through).

    **IMPORTANT:** The use case needs a `numero` (correlativo). For the MVP, accept a `numero` field in the input (7-digit string). The caller (API layer) will be responsible for generating the next correlative number. This keeps the use case simple and avoids introducing a number-generation port prematurely.

    Update CrearFacturaInput to include `numero: string` (7-digit correlativo).

    All tests should FAIL at this point because CrearFactura.ts does not exist yet.
  </action>
  <verify>Run `cd nandefact-api && npx vitest run tests/unit/application/facturacion/CrearFactura.test.ts` — ALL tests must FAIL (file not found or import errors). This confirms RED phase. Existing domain tests must still pass: `npx vitest run tests/unit/domain/`.</verify>
  <done>6 test cases written for CrearFactura. All 6 fail because implementation doesn't exist. Existing 59 domain tests still pass.</done>
</task>

<task type="auto">
  <name>Task 3: GREEN — Implement CrearFactura use case to pass all tests</name>
  <files>
    nandefact-api/src/application/facturacion/CrearFactura.ts
  </files>
  <action>
    Create `src/application/facturacion/CrearFactura.ts` implementing the use case:

    **Exports:**
    - `CrearFacturaInput` — input DTO type (plain object, not domain entity)
    - `CrearFacturaOutput` — output DTO type (plain object with: facturaId, cdc, estado, totalBruto, totalIVA10, totalIVA5, totalExenta, totalIVA)
    - `CrearFactura` — use case class

    **CrearFactura class:**
    - Constructor takes: `{ facturaRepository: IFacturaRepository, comercioRepository: IComercioRepository }`
    - `async execute(input: CrearFacturaInput): Promise<CrearFacturaOutput>`

    **execute() flow:**
    1. Load comercio: `await this.comercioRepository.findById(input.comercioId)` — if null, throw `ComercioNoEncontradoError(input.comercioId)`
    2. Generate UUID for facturaId using `crypto.randomUUID()` (built-in Node.js 20+)
    3. Create NumeroFactura from comercio.establecimiento, comercio.puntoExpedicion, and input.numero
    4. Create Factura with: { id: facturaId, comercioId: input.comercioId, clienteId: input.clienteId, tipoDocumento: input.tipoDocumento, timbrado: comercio.timbrado, numeroFactura, tipoEmision: 1 (normal), condicionPago: input.condicionPago, fechaEmision: input.fechaEmision }
    5. For each item in input.items: create ItemFactura and call factura.agregarItem()
    6. Call factura.generarCDC(comercio.ruc, comercio.tipoContribuyente)
    7. Call `await this.facturaRepository.save(factura)`
    8. Return CrearFacturaOutput with all totals and cdc.value

    **Important implementation details:**
    - Use `.js` extensions in all imports (ESM)
    - Import from domain layer: `@domain/factura/Factura.js` does NOT work at runtime with vitest alias resolution — use relative paths: `../../domain/factura/Factura.js`
    - Actually, check vitest.config.ts — it defines aliases. Use relative imports to be safe: `../../domain/...`
    - cdc getter on Factura returns `CDC | null`. After generarCDC, it will be non-null. Use non-null assertion `factura.cdc!.value` since we just called generarCDC (or add a check and throw).
    - `input.items` must have at least 1 item (domain enforces via FacturaSinItemsError when calling generarCDC on empty items). The domain error will naturally bubble up.
    - All types use the ones from `@domain/shared/types.js`

    After implementing, remove `.gitkeep` from `src/application/facturacion/` if it exists.
  </action>
  <verify>Run `cd nandefact-api && npx vitest run tests/unit/application/facturacion/CrearFactura.test.ts` — ALL 6 tests must PASS. Then run `npx vitest run` — ALL tests (59 domain + 6 new) must pass. Then run `npx tsc --noEmit` — must compile.</verify>
  <done>CrearFactura use case passes all 6 tests. Total test count is 65. TypeScript compiles with zero errors. Input/Output DTOs are clean types (not domain entities).</done>
</task>

</tasks>

<verification>
1. `cd nandefact-api && npx tsc --noEmit` — zero TypeScript errors
2. `cd nandefact-api && npx vitest run` — 65 tests passing (59 existing + 6 new)
3. CrearFactura use case exists at `src/application/facturacion/CrearFactura.ts`
4. Application errors exist at `src/application/errors/`
5. IComercioRepository port exists at `src/domain/comercio/IComercioRepository.ts`
6. No `.gitkeep` files remain in directories that now have real files
</verification>

<success_criteria>
- CrearFactura.execute() accepts DTO input, orchestrates domain entities, persists via port, returns DTO output
- Application errors are separate from domain errors
- IComercioRepository port follows same pattern as IFacturaRepository
- All 65 tests pass (zero regressions)
- TypeScript strict mode compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-application-layer/01-01-SUMMARY.md`
</output>
