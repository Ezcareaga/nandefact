---
phase: 02-sifen-integration
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - nandefact-api/src/infrastructure/sifen/FirmaDigitalSifen.ts
  - nandefact-api/src/infrastructure/sifen/SifenGatewayImpl.ts
  - nandefact-api/src/infrastructure/sifen/SifenConfig.ts
  - nandefact-api/tests/unit/infrastructure/sifen/FirmaDigitalSifen.test.ts
  - nandefact-api/tests/unit/infrastructure/sifen/SifenGatewayImpl.test.ts
  - nandefact-api/package.json
autonomous: true

must_haves:
  truths:
    - "FirmaDigitalSifen adapter signs XML using facturacionelectronicapy-xmlsign library"
    - "SifenGatewayImpl adapter communicates with SIFEN via facturacionelectronicapy-setapi"
    - "SifenGatewayImpl parses SIFEN response codes correctly (0260=aprobado, 0300+=rechazado)"
    - "SifenGatewayImpl can query DE status by CDC using siConsDE"
    - "SifenGatewayImpl can send cancelation event for a CDC"
    - "All adapters use SifenConfig for certificate path, password, and environment"
  artifacts:
    - path: "nandefact-api/src/infrastructure/sifen/FirmaDigitalSifen.ts"
      provides: "XML signing adapter"
      contains: "facturacionelectronicapy-xmlsign"
    - path: "nandefact-api/src/infrastructure/sifen/SifenGatewayImpl.ts"
      provides: "SIFEN SOAP communication adapter"
      contains: "facturacionelectronicapy-setapi"
    - path: "nandefact-api/src/infrastructure/sifen/SifenConfig.ts"
      provides: "Centralized SIFEN configuration"
      contains: "certificatePath"
    - path: "nandefact-api/tests/unit/infrastructure/sifen/FirmaDigitalSifen.test.ts"
      provides: "Signing adapter tests"
      min_lines: 30
    - path: "nandefact-api/tests/unit/infrastructure/sifen/SifenGatewayImpl.test.ts"
      provides: "Gateway adapter tests"
      min_lines: 50
  key_links:
    - from: "nandefact-api/src/infrastructure/sifen/FirmaDigitalSifen.ts"
      to: "nandefact-api/src/domain/factura/IFirmaDigital.ts"
      via: "implements IFirmaDigital"
      pattern: "implements IFirmaDigital"
    - from: "nandefact-api/src/infrastructure/sifen/SifenGatewayImpl.ts"
      to: "nandefact-api/src/domain/factura/ISifenGateway.ts"
      via: "implements ISifenGateway"
      pattern: "implements ISifenGateway"
    - from: "nandefact-api/src/infrastructure/sifen/SifenGatewayImpl.ts"
      to: "facturacionelectronicapy-setapi"
      via: "import setApi"
      pattern: "facturacionelectronicapy-setapi"
---

<objective>
Create the FirmaDigitalSifen and SifenGatewayImpl infrastructure adapters that implement the IFirmaDigital and ISifenGateway domain ports using the TIPS-SA npm libraries for XML signing and SIFEN SOAP communication.

Purpose: These adapters complete the SIFEN integration infrastructure. FirmaDigitalSifen signs XML with CCFE certificates (XMLDSig RSA-2048, SHA-256). SifenGatewayImpl communicates with SIFEN Web Services (siRecepDE for sending, siConsDE for querying, evento for cancelation). Both are tested with mocks since no real CCFE certificate is available yet.

Output: FirmaDigitalSifen adapter, SifenGatewayImpl adapter, SifenConfig configuration class, and TDD tests for both adapters.
</objective>

<execution_context>
@/home/ez/.claude/get-shit-done/workflows/execute-plan.md
@/home/ez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Domain ports these adapters implement:
@nandefact-api/src/domain/factura/IFirmaDigital.ts
@nandefact-api/src/domain/factura/ISifenGateway.ts

# Package config:
@nandefact-api/package.json
@nandefact-api/tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install libraries + Create SifenConfig + Write failing tests (RED)</name>
  <files>
    nandefact-api/package.json
    nandefact-api/src/infrastructure/sifen/SifenConfig.ts
    nandefact-api/src/infrastructure/sifen/FirmaDigitalSifen.ts
    nandefact-api/src/infrastructure/sifen/SifenGatewayImpl.ts
    nandefact-api/tests/unit/infrastructure/sifen/FirmaDigitalSifen.test.ts
    nandefact-api/tests/unit/infrastructure/sifen/SifenGatewayImpl.test.ts
  </files>
  <action>
**Step 1: Install dependencies**

```bash
cd nandefact-api && npm install facturacionelectronicapy-xmlsign facturacionelectronicapy-setapi
```

**Step 2: Create SifenConfig** in `src/infrastructure/sifen/SifenConfig.ts`:

Centralized configuration for all SIFEN-related adapters. Reads from constructor parameters (in production, values come from env vars via dependency injection).

```typescript
export type SifenEnvironment = 'test' | 'prod';

export interface SifenConfigProps {
  environment: SifenEnvironment;
  certificatePath: string;        // Path to .p12/.pfx file
  certificatePassword: string;    // Password for the certificate
  privateKeyPath?: string;        // Path to private key file (for mutual TLS)
}

/** Configuración centralizada para servicios SIFEN */
export class SifenConfig {
  readonly environment: SifenEnvironment;
  readonly certificatePath: string;
  readonly certificatePassword: string;
  readonly privateKeyPath: string;

  constructor(props: SifenConfigProps) {
    if (!props.certificatePath) {
      throw new Error('SIFEN: certificatePath es requerido');
    }
    if (!props.certificatePassword) {
      throw new Error('SIFEN: certificatePassword es requerido');
    }

    this.environment = props.environment;
    this.certificatePath = props.certificatePath;
    this.certificatePassword = props.certificatePassword;
    this.privateKeyPath = props.privateKeyPath ?? props.certificatePath;
  }

  /** Retorna la URL base de SIFEN según el entorno */
  get baseUrl(): string {
    return this.environment === 'test'
      ? 'https://sifen-test.set.gov.py/de/ws/'
      : 'https://sifen.set.gov.py/de/ws/';
  }
}
```

**Step 3: Create skeleton FirmaDigitalSifen** in `src/infrastructure/sifen/FirmaDigitalSifen.ts`:

```typescript
import type { IFirmaDigital } from '../../domain/factura/IFirmaDigital.js';
import type { SifenConfig } from './SifenConfig.js';

/** Adaptador — Firma digital XMLDSig usando librería TIPS-SA xmlsign */
export class FirmaDigitalSifen implements IFirmaDigital {
  constructor(private readonly config: SifenConfig) {}

  async firmar(xmlString: string): Promise<string> {
    // TODO: implementar en GREEN
    throw new Error('Not implemented');
  }
}
```

**Step 4: Create skeleton SifenGatewayImpl** in `src/infrastructure/sifen/SifenGatewayImpl.ts`:

```typescript
import type { ISifenGateway, SifenResponse } from '../../domain/factura/ISifenGateway.js';
import type { SifenConfig } from './SifenConfig.js';

/** Adaptador — Comunicación con Web Services SIFEN (SOAP) vía TIPS-SA setapi */
export class SifenGatewayImpl implements ISifenGateway {
  constructor(private readonly config: SifenConfig) {}

  async enviarDE(xmlFirmado: string): Promise<SifenResponse> {
    // TODO: implementar en GREEN
    throw new Error('Not implemented');
  }

  async consultarEstado(cdc: string): Promise<SifenResponse> {
    // TODO: implementar en GREEN
    throw new Error('Not implemented');
  }

  async anularDE(cdc: string, motivo: string): Promise<SifenResponse> {
    // TODO: implementar en GREEN
    throw new Error('Not implemented');
  }
}
```

**Step 5: Write failing tests for FirmaDigitalSifen** in `tests/unit/infrastructure/sifen/FirmaDigitalSifen.test.ts`:

Since we cannot call the real xmlsign library without a valid certificate, we MOCK the library.

Use `vi.mock('facturacionelectronicapy-xmlsign')` to mock the xmlsign module.

Test cases:
1. "debe llamar a xmlsign.signXML con el XML, ruta del certificado y password" - Verify mock called with correct args
2. "debe retornar el XML firmado por la librería" - Verify return value from mock
3. "debe propagar error si la firma falla" - Verify error propagation
4. "debe usar certificatePath y certificatePassword de SifenConfig" - Verify config usage

**Step 6: Write failing tests for SifenGatewayImpl** in `tests/unit/infrastructure/sifen/SifenGatewayImpl.test.ts`:

Mock `facturacionelectronicapy-setapi` module.

Test cases for `enviarDE`:
1. "debe llamar a setApi.recibe con XML firmado y entorno test" - Verify mock args
2. "debe parsear respuesta aprobada (código 0260) correctamente" - Mock returns approval XML/response
3. "debe parsear respuesta rechazada (código 0300) correctamente" - Mock returns rejection
4. "debe parsear respuesta aprobada con observación (código 0261)"
5. "debe propagar error si el servicio SIFEN falla (error de red)"

Test cases for `consultarEstado`:
6. "debe llamar a setApi.consulta con CDC y entorno" - Verify mock args
7. "debe retornar estado del DE encontrado" - Mock returns consulta response
8. "debe manejar DE no encontrado" - Mock returns not-found response

Test cases for `anularDE`:
9. "debe llamar a setApi.evento con XML de cancelación y entorno" - Verify mock args
10. "debe retornar resultado de cancelación exitosa"
11. "debe retornar resultado de cancelación fallida"

IMPORTANT: The TIPS-SA setapi library returns XML responses that need to be parsed. The tests should mock the library to return structured responses. Research the actual return format of `setApi.recibe()` — it likely returns an XML string or parsed object. The adapter must parse SIFEN response codes from whatever format the library returns.

The setapi `recibe()` function signature is: `recibe(id, xmlSigned, env, cert_path, key)` where:
- `id`: request ID (use UUID)
- `xmlSigned`: signed XML string
- `env`: "test" or "prod"
- `cert_path`: path to .p12 certificate
- `key`: password or private key

Run tests and verify they all FAIL.

Commit: `test(02-02): add failing tests for FirmaDigitalSifen and SifenGatewayImpl (RED)`
  </action>
  <verify>
Run `cd nandefact-api && npx vitest run tests/unit/infrastructure/sifen/FirmaDigitalSifen.test.ts tests/unit/infrastructure/sifen/SifenGatewayImpl.test.ts` and verify tests exist and FAIL because implementations throw 'Not implemented'. The packages `facturacionelectronicapy-xmlsign` and `facturacionelectronicapy-setapi` must be in package.json dependencies.
  </verify>
  <done>
SifenConfig class exists with environment, certificate, and URL configuration. FirmaDigitalSifen and SifenGatewayImpl skeleton classes exist implementing their ports. 15+ failing tests exist covering signing, sending, querying, and cancellation scenarios. Both TIPS-SA libraries installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FirmaDigitalSifen + SifenGatewayImpl (GREEN)</name>
  <files>
    nandefact-api/src/infrastructure/sifen/FirmaDigitalSifen.ts
    nandefact-api/src/infrastructure/sifen/SifenGatewayImpl.ts
  </files>
  <action>
**Step 1: Implement FirmaDigitalSifen**

```typescript
import xmlsign from 'facturacionelectronicapy-xmlsign';
import type { IFirmaDigital } from '../../domain/factura/IFirmaDigital.js';
import type { SifenConfig } from './SifenConfig.js';

export class FirmaDigitalSifen implements IFirmaDigital {
  constructor(private readonly config: SifenConfig) {}

  async firmar(xmlString: string): Promise<string> {
    if (!xmlString || xmlString.trim().length === 0) {
      throw new Error('XML vacío no se puede firmar');
    }

    const xmlFirmado = await xmlsign.signXML(
      xmlString,
      this.config.certificatePath,
      this.config.certificatePassword,
    );

    return xmlFirmado;
  }
}
```

If xmlsign is CommonJS, use `import * as xmlsign from 'facturacionelectronicapy-xmlsign'` or check if there's a default export. Adjust the import based on what the package actually exports.

**Step 2: Implement SifenGatewayImpl**

The setapi library functions return responses that contain SIFEN status codes. The adapter must:
1. Call the appropriate setapi function
2. Parse the response to extract the SIFEN code and message
3. Map to our SifenResponse interface

```typescript
import setApi from 'facturacionelectronicapy-setapi';
import type { ISifenGateway, SifenResponse } from '../../domain/factura/ISifenGateway.js';
import type { SifenConfig } from './SifenConfig.js';
import { randomUUID } from 'crypto';

export class SifenGatewayImpl implements ISifenGateway {
  constructor(private readonly config: SifenConfig) {}

  async enviarDE(xmlFirmado: string): Promise<SifenResponse> {
    const id = randomUUID();

    try {
      const response = await setApi.recibe(
        id,
        xmlFirmado,
        this.config.environment,
        this.config.certificatePath,
        this.config.certificatePassword,
      );

      return this.parseSifenResponse(response, xmlFirmado);
    } catch (error) {
      // Error de red o comunicación
      throw new Error(
        `Error al enviar DE a SIFEN: ${error instanceof Error ? error.message : 'Error desconocido'}`,
      );
    }
  }

  async consultarEstado(cdc: string): Promise<SifenResponse> {
    const id = randomUUID();

    try {
      const response = await setApi.consulta(
        id,
        cdc,
        this.config.environment,
        this.config.certificatePath,
        this.config.certificatePassword,
      );

      return this.parseConsultaResponse(response, cdc);
    } catch (error) {
      throw new Error(
        `Error al consultar DE en SIFEN: ${error instanceof Error ? error.message : 'Error desconocido'}`,
      );
    }
  }

  async anularDE(cdc: string, motivo: string): Promise<SifenResponse> {
    const id = randomUUID();

    // Para cancelación, necesitamos enviar un XML de evento.
    // El XML de evento de cancelación se genera con xmlgen.generateXMLEventoCancelacion()
    // pero eso sería responsabilidad del caller o un servicio separado.
    // Por ahora, el adapter envía el evento directamente con los parámetros del CDC.
    try {
      const response = await setApi.evento(
        id,
        cdc,  // El XML de evento cancelación
        this.config.environment,
        this.config.certificatePath,
        this.config.certificatePassword,
      );

      return this.parseEventoResponse(response, cdc);
    } catch (error) {
      throw new Error(
        `Error al anular DE en SIFEN: ${error instanceof Error ? error.message : 'Error desconocido'}`,
      );
    }
  }

  /**
   * Parsea la respuesta SIFEN de envío individual (siRecepDE).
   * La respuesta contiene el código de estado del DE.
   */
  private parseSifenResponse(response: unknown, xmlOriginal: string): SifenResponse {
    // La respuesta del setapi puede ser un XML string o un objeto parseado.
    // Extraemos el código de respuesta y mensaje.
    // Si la respuesta es un string XML, parseamos los tags relevantes.
    // Si es un objeto, accedemos directamente.

    if (typeof response === 'string') {
      const codigo = this.extractXmlValue(response, 'dCodRes') ?? '0000';
      const mensaje = this.extractXmlValue(response, 'dMsgRes') ?? 'Sin mensaje';
      const cdc = this.extractXmlValue(response, 'Id') ?? this.extractCdcFromXml(xmlOriginal);
      return { codigo, mensaje, cdc };
    }

    // Si es objeto (algunas versiones de setapi pueden devolver objetos)
    const obj = response as Record<string, unknown>;
    return {
      codigo: String(obj['dCodRes'] ?? obj['codigo'] ?? '0000'),
      mensaje: String(obj['dMsgRes'] ?? obj['mensaje'] ?? 'Sin mensaje'),
      cdc: String(obj['Id'] ?? obj['cdc'] ?? ''),
    };
  }

  private parseConsultaResponse(response: unknown, cdc: string): SifenResponse {
    if (typeof response === 'string') {
      const codigo = this.extractXmlValue(response, 'dCodRes') ?? '0000';
      const mensaje = this.extractXmlValue(response, 'dMsgRes') ?? 'Sin mensaje';
      return { codigo, mensaje, cdc };
    }

    const obj = response as Record<string, unknown>;
    return {
      codigo: String(obj['dCodRes'] ?? obj['codigo'] ?? '0000'),
      mensaje: String(obj['dMsgRes'] ?? obj['mensaje'] ?? 'Sin mensaje'),
      cdc,
    };
  }

  private parseEventoResponse(response: unknown, cdc: string): SifenResponse {
    if (typeof response === 'string') {
      const codigo = this.extractXmlValue(response, 'dCodRes') ?? '0000';
      const mensaje = this.extractXmlValue(response, 'dMsgRes') ?? 'Sin mensaje';
      return { codigo, mensaje, cdc };
    }

    const obj = response as Record<string, unknown>;
    return {
      codigo: String(obj['dCodRes'] ?? obj['codigo'] ?? '0000'),
      mensaje: String(obj['dMsgRes'] ?? obj['mensaje'] ?? 'Sin mensaje'),
      cdc,
    };
  }

  /** Extrae un valor de un tag XML simple (no usa parser XML completo) */
  private extractXmlValue(xml: string, tagName: string): string | null {
    const regex = new RegExp(`<${tagName}[^>]*>([^<]+)</${tagName}>`);
    const match = regex.exec(xml);
    return match?.[1] ?? null;
  }

  /** Extrae el CDC del XML original del DE */
  private extractCdcFromXml(xml: string): string {
    return this.extractXmlValue(xml, 'Id') ?? this.extractXmlValue(xml, 'CDC') ?? '';
  }
}
```

IMPORTANT NOTES:
- The setapi library's response format may vary between versions. The parsing logic should be defensive.
- If the library returns a parsed object instead of XML string, adjust the parsing accordingly.
- The `extractXmlValue` is a simple regex parser for the limited set of SIFEN response tags we need. A full XML parser is NOT needed for these simple response extractions.
- The `anularDE` method simplification: in a complete implementation, the event XML for cancelation should be generated by xmlgen's `generateXMLEventoCancelacion()` and then signed before sending. For this phase, the adapter accepts the CDC and delegates event XML handling. The full event flow will be refined in Phase 4.

Run all tests and verify PASS.

Commit: `feat(02-02): implement FirmaDigitalSifen and SifenGatewayImpl (GREEN)`
  </action>
  <verify>
Run `cd nandefact-api && npx vitest run tests/unit/infrastructure/sifen/FirmaDigitalSifen.test.ts tests/unit/infrastructure/sifen/SifenGatewayImpl.test.ts` and verify ALL tests pass. Run `cd nandefact-api && npx vitest run` to verify zero regressions (all existing tests + new tests pass). Run `npx tsc --noEmit` to verify TypeScript compiles.
  </verify>
  <done>
FirmaDigitalSifen adapter signs XML using xmlsign library via SifenConfig (4+ tests passing). SifenGatewayImpl adapter communicates with SIFEN using setapi for enviarDE, consultarEstado, and anularDE (11+ tests passing). SIFEN response codes parsed correctly. All existing tests still pass. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `cd nandefact-api && npx vitest run` — All tests pass (81 existing + ~15 new = ~96 total)
2. `npx tsc --noEmit` — TypeScript compiles clean
3. `grep -r "facturacionelectronicapy-xmlsign" nandefact-api/package.json` — xmlsign installed
4. `grep -r "facturacionelectronicapy-setapi" nandefact-api/package.json` — setapi installed
5. `grep "implements IFirmaDigital" nandefact-api/src/infrastructure/sifen/FirmaDigitalSifen.ts` — Adapter implements port
6. `grep "implements ISifenGateway" nandefact-api/src/infrastructure/sifen/SifenGatewayImpl.ts` — Adapter implements port
7. `test -f nandefact-api/src/infrastructure/sifen/SifenConfig.ts` — Config class exists
</verification>

<success_criteria>
- FirmaDigitalSifen implements IFirmaDigital using facturacionelectronicapy-xmlsign
- SifenGatewayImpl implements ISifenGateway using facturacionelectronicapy-setapi
- SifenConfig centralizes certificate path, password, and environment
- SIFEN response codes (0260, 0261, 0300+) parsed correctly from responses
- All methods tested with mocked external libraries (no real SIFEN calls)
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-sifen-integration/02-02-SUMMARY.md`
</output>
